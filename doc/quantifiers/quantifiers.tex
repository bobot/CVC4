\documentclass{llncs}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{comment}
%\usepackage{fullpage}
\usepackage{proof}
\usepackage{url}
\usepackage[pdftex]{graphicx}
\usepackage[usenames]{color}
\usepackage{capt-of}
\usepackage{program}

\newtheorem{thm}{Theorem}
\newtheorem{cor}{Corollary}

\newcommand{\interp}[1]{[ \negthinspace [ #1 ] \negthinspace ]}

\newcommand{\ednote}[1]{{\bf [#1]}\message{ednote!}}

\newcommand{\bassert}{|assert|_\mathrm{base}}
\newcommand{\iassert}{|assert|_\mathrm{ind}}
\newcommand{\bentail}{|entailed|_\mathrm{base}}
\newcommand{\ientail}{|entailed|_\mathrm{ind}}
\newcommand{\breset}{|reset|_\mathrm{base}}
\newcommand{\ireset}{|reset|_\mathrm{ind}}
\newcommand{\bcex}{|cex|_\mathrm{base}}
\newcommand{\icex}{|cex|_\mathrm{ind}}
\def\LOOP{\qtab\keyword{loop}\ }
\def\ENDLOOP{\untab}
\def\REPEAT{\qtab\keyword{repeat}\ }
\def\UNTIL{\untab\keyword{until}\ }
\def\IF{\qtab\keyword{if}\ }
\def\THEN{\ \keyword{then}\ }
\def\ELSE{\untab\qtab\keyword{else}\ }
\def\ELSEIF{\untab\qtab\keyword{else if}\ }
\def\FI{\untab}
\def\RETURN{\keyword{return}\ }
\def\ENDPROC{\untab}
\def\DOFOR{\qtab\keyword{for}\ }
\def\ENDFOR{\untab}
\def\COMMENT#1{\texttt{// #1}}
\def\keyword#1{\mbox{\normalshape\bf #1}}
\def\MATCH{\qtab\keyword{match}\ }
\def\WITH{\ \keyword{with}\ }
\def\ENDMATCH{\untab}
%\def\WHILE{\qtab\keyword{while}\ }
\def\ENDWHILE{\untab}

\newcommand{\To}{\Rightarrow}


\begin{document}
\pagenumbering{arabic}
\pagestyle{plain}

\title{A Counterexample-Based Approach for Quantifier Instantiation in SMT}

\author{Andrew Reynolds}
\institute{Computer Science, The University of Iowa, USA}

\date{}

\maketitle
\thispagestyle{empty}

\section{DPLL(T) Approach to Quantifiers}

When extending the DPPL(T) framework to handle formulas involving quantifiers, we rely on the following rules: \\

\noindent $\exists$-Inst: \\

$M \parallel F \Longrightarrow M \parallel F, \neg \exists \bar{x}. \varphi[ \bar{ x } ] \vee \varphi[ \bar{ c }/\bar{x} ]$, if   
$\begin{cases}
  \exists \bar{x}. \varphi[ \bar{ x } ] \in M \\
  \bar{ c } \text{ are fresh constants} \\
\end{cases}$ \\

\noindent $\forall$-Inst: \\

$M \parallel F \Longrightarrow M \parallel F, \neg \forall \bar{x}. \varphi[ \bar{ x } ] \vee \varphi[ \bar{ s }/\bar{x} ]$, if   
$\begin{cases}
  \forall \bar{x}. \varphi[ \bar{ x } ] \in M \\
  \bar{ s } \text{ are ground terms} \\
\end{cases}$ \\

We call the constants introduced in $\exists$-Inst as skolem constants.
Note that in the case of $\exists$-Inst, there is no benefit of instantiating more than once.

Note that the $\forall$-Inst rule always applies in DPLL(T) when a universal quantified formula is asserted, thus restricting the SMT solver from answering SAT.
Typically, repeated applications of $\forall$-Inst are tried until a conflict is discovered, or else the solver returns UNKNOWN.
The main challenges here are (1) determining relevant instantiations to use for the rule $\forall$-Inst, (2) determining when it is no longer worthwhile to apply $\forall$-Inst for a given quantifier, and furthermore (3) recognizing cases where \emph{all} necessary instantiations have been tried.

In current approaches, $E$-matching has been used as a method of addressing challenge (1).
In $E$-matching, subterms contained in a quantifier are matched against ground terms to find substitutions that are then used to instantiate a given quantifier.
While simple and effective, current approaches to $E$-matching are limited in their ability to determine the instantiations that are the most helpful at any given time.
As a result, often a brute force approach is used, in which many useless instantiations are produced in addition to those used to generate conflicts.

Approaches based on $E$-matching also suffer at times from what is known as a \emph{matching loop}, that is, a situation in which ground terms generated by instantiations may lead to matches of a repeating form.
Heuristics have been used to address the challenges of (2), including assigning an instantiation level to each ground term produced as a result of an instantiation.
By giving preference to matches using ground terms of a lower instantiation level, our instantiations effectively can be thought of as a bredth-first search.

Some SMT solvers employ what is known as \emph{complete instantiation} when dealing with problems containing quantifiers to address (3).
If the solver can recognize that the quantifier occurs in a decidable fragment of first order logic, then the solver may only need to try a finite number of instantiations before either finding a conflict or determining the quantified formula is valid.
In the cases where the formula is found to be valid, then the solver may be able to answer SAT.

The following document reexamines challenges (1), (2) and (3).
We present a scheme for symbolically reasoning about counterexamples to quantified formulas within the DPLL(T) framework.
At a high level, for every (universally) quantified formula $\psi$ asserted in a given context, the solver will assume that a counterexample to $\psi$ exists, and reason about possible values for this counterexample.

In terms of challenge (1), the goal of this approach will be to leverage theory-specific information to aid in selecting instantiations.
Say we have a universally quantified formula $\forall x. \varphi[x]$ where $x$ is of a sort belonging to theory $T$.
The SMT solver will be interested in finding a satisifying assignment for $ \neg \varphi[e/x]$ where $e$ is a fresh constant of the same sort as $x$.
In other words, the value of $e$ will represent the possible values for which our quantified formula can be falsified.
The theory solver for $T$ will suggest instantiations for $x$ based on the internal information it has deduced involving $e$.
For the theory of $EUF$, this can be thought of as an extension to E-matching.

For challenge (3), it can be shown that if $\neg \varphi[e/x]$ is unsatisfiable in the current context for fresh constant $e$, then our quantified formula is valid in the current context and need not be instantiated further.
This comes as an added benefit, and while not as powerful as techniques using complete instantiation, may lead to SAT instances when it is shown that a particular axiom does not apply in a particular context.

\subsection{Related Work}

\paragraph{Model-Based Quantifier Instantiation}
Model-Based Quantifier Instantiation (MBQI) has been proposed as a powerful method for addressing challenges (1) and (3).
For a quantified formula $\forall \bar{x}. \varphi(\bar{x})$
The goal of MBQI is to determine relevant instantiations using models to ground clauses in the current context.
More specifically, given a set of clauses $F$, we determine a candidate model $M^I$ for the ground clauses in $F$, as well as other restrictions $R$ on potential models.
For each quantified assertion $\forall x. \varphi[x] \in F$, we check the satisifiability of $R \wedge \neg \varphi^I[e/x]$, where $\varphi^I$ is generated by replacing all uninterpretted symbols in $\varphi$ with the interpretation in our model $M^I$.
In the case that this formula is satisfiable for some $\varphi^I[e/x]$, we use a model for this formula to instantiate $\forall x. \varphi[x]$, thereby ruling out the model $M^I$ on future iterations.
In the case that each of these formulas $R \wedge \neg \varphi^I[e/x]$ are unsatisifiable, then we know that our formula is SAT.

%However, a weakness of this approach is that it is not incremental.
%In other words, testing the satisfiability of formulas $R \wedge \neg \varphi^I[e]$ potentially comes at a large cost to the solver.

The technique proposed in this document takes a similar approach to quantifier instantiation, and is intended to simplify this scheme.
Instead of explicitly building models $M^I$ and reasoning about the interpretted form of clauses $\neg \varphi^I[e/x]$, we instead reason  about the negated body of non-ground clauses $\neg \varphi[e]$ for a fresh (distinguished) constant $e$, which we will refer to as an \emph{instantiation constant}.
This is done using the same instance of the SMT solver, that is, we may use an SMT solver to simultaneously reason about constructing satisfying assignments for ground clauses existing in a particular problem as well as clauses representing counterexamples $\neg \varphi[e/x]$.
An immediate advantage here is that reasoning about the negated body of the quantifier is performed incrementally.
In this approach, when we have reached a DPLL(T) state $M \parallel F$, our current set of asserted literals $M$ not containing $e$ can be considered the implicit specification of a current model.

Based on possible values we find for $e$, our procedure will construct instantiations that are likely to be relevant in the current context, as well as decide when no helpful instantiations exist.
In a similar manner as model-based quantifier instantiation, if we show that $\neg \varphi[e]$ is unsatisifiable in the current context for the fresh constant $e$, then we have shown that $\forall x. \varphi[x]$ is valid and need not be instantiated further in the current context.

\paragraph{E-matching}
E-matching is a powerful method for generating relevant instantiations based on matching \emph{triggers} with concrete ground terms. 
Say we have ground assertions $M$ and quantified assertion $\forall \bar{x}. \varphi$.
The idea of E-matching is to find a subterm (or set of subterms) $t$ of $\varphi$, called a \emph{trigger}, such that all variables $\bar{x}$ are contained in the free variables of $t$, and a vector of ground terms $\bar{s}$ such that $t[\bar{s}/\bar{x}]$ is equivalent to a ground subterm $g$ of $M$ modulo a set of ground equalities entailed by $M$.
In this case, we say that term $t$ \emph{E-matches} term $g$ and subsequently the set of ground terms $\bar{s}$ is used to instantiate the quantifier $\forall \bar{x}. \varphi$.

While modern methods can be used to compute E-matches in a highly efficient manner, a weakness of E-matching is its ability to recognize the relevance of instantiations in a precise way.
In particular, a basic implementation of E-matching does not consider the logical structure of the body of the quantifier $\varphi$.
As a result, many instantiations may potentially be needed to generate a conflict if one exists.

As a simple case, say we have the literals $f( a ) = g( a )$ and $\forall x. ( f(x) \neq g(x) \Rightarrow P( x ) )$ asserted in a particular context. 
An implementation of E-matching may choose $f( x )$ as a trigger and use $a$ as an instantiation for the quantifier.
However, this instantiation may not be helpful since it falsifies the antecedant of the body of the quantifier.
To recognize such cases, it is useful to reason about the negated body of the quantifier for a fresh constant $e$, where in this case the SMT solver will assert the literals $f( e ) \neq g( e )$ and $\neg P( e )$.
This will suggest that ideally we should be looking for a ground term $a$ such that $f( a ) \neq g( a )$, and ideally an $a$ in which $\neg P( a )$ holds as well.

The technique in the following can be thought of as an extension to E-matching, where now equalities and disequalities between triggers are considered.
This information provides a criteria for filtering irrelevant E-matches, as well as a way of quickly finding instantiations that are more likely to be relevant.

\section{DPLL(T) with Counterexample Literals}
\label{dpll-ce-lit}

In this section, we propose a scheme for reasoning about quantified formulas in SMT within the existing DPLL(T) framework.
This scheme will supplement DPLL(T) with an additional rule (Counterexample $\forall$-Inst) as well as enhancements for existing DPLL(T) rules related to quantifiers.
The core semantics of the DPLL(T) architechture will remain the same, that is, we still consider states of the form $M \parallel F$, where $M$ is a set of asserted literals and $F$ is a set of clauses.

\begin{comment}
Throughout the remainder of this document, we will assume that CNF-conversion has been applied to the body of all universally quantified formulas.
In other words, the only quantified formulas we consider are non-ground clauses of the form $\forall \bar{x}. ( l_1 \vee \ldots \vee l_n )[\bar{x}]$, where $l_1 \ldots l_n$ are theory literals.
\end{comment}

\subsection{Counterexample Literals}

Given an asserted quantifier $\forall \bar{x}. \varphi[\bar{x}]$ (call this formula $\psi$) and a DPLL(T) context $M \parallel F$, we are interested in finding a satisifying assignment for $ \neg \psi[\bar{e}/\bar{x}]$ for fresh constants $\bar{e}$.
To do this, we will insert a valid lemma into $F$ that gives three possibilities for $\psi$: either $\psi$ is not asserted, $\psi$ does not have a counterexample, or $\psi$ has a counterexample, call it $\bar{e}$, such that $\neg \varphi[\bar{e}/\bar{x}]$ holds.
We now introduce the notion of a \emph{counterexample literal}.

For a quantified formula $\psi$ of the form $\forall \bar{ x }. \varphi$, we will associate a distinguished (boolean) literal $\bot^\psi$ called the \emph{counterexample literal of $\psi$}, with the intended meaning that ``a counterexample to $\psi$ exists".
The idea here is that although this entails the literal $\neg \psi$ itself, we will in a sense trick the SAT-solver into believing that $\psi$ and $\bot^\psi$ are in fact independent literals.

For a DPLL(T) state $M \parallel F$ and for each quantified formula $\psi = \forall \bar{ x }. \varphi[ \bar{ x } ] \in F$, we have three intended configurations for $\psi$ and its counterexample literal $\neg \bot^\psi$: \\

(1) $\psi$ is not asserted positively in $M$, 

(2) $\psi^{(d)}$ and $(\bot^\psi)^d$ are asserted in $M$, 

(3) $\psi^{(d)}$ and $\neg \bot^\psi$ are asserted in $M$. \\

In case (1), our configuration does not claim $\psi$ to be true.
In case (2), our configuration has asserted (perhaps as a decision) that $\psi$ is true, but also has decided that a counterexample will be found.
In case (3), our configuration has asserted that $\psi$ is true, and moreover knows that $\psi$ does not have a counterexample.
To enforce this schema, we require that the DPLL(T) engine never assert $\neg (\bot^\psi)^d$ as a decision.
This requirement can be addressed within the core of the SAT solver, with a negligible impact on performance.

%In the following sections, lemmas of the form $( \neg \psi \vee \neg \bot^\psi \vee \neg \psi[\bar{e}/\bar{x}])$ will be added to our set of clauses $F$.
%Each of these clauses tell us that either $\psi$ does not hold, a counterexample does not exist for $\psi$, or the contraint $C(\bar{e})$ holds for the counterexample $\bar{e}$ of $\psi$,  where $\bar{e}$ are distinguished free constants of the same sorts as $\bar{x}$.
%In other words, if there exists a $\bar{t}$ such that $\psi[\bar{t}/\bar{x}]$ is unsatisifiable in $M$, then $C( \bar{t})$ is satisfiable in $M$.
%Note the contrapositive: if $C( \bar{e} )$ is unsatisfiable in $M$, then $\psi[\bar{t}/\bar{x}]$ is satisifiable in $M$ for all $\bar{t}$, or in other words, $\psi$ does not have a counterexample and $\psi$ is valid.

For a quantifier $\psi$, we will be interested in finding a satisifying assignment for the clause $( \neg \psi \vee \neg \bot^\psi \vee \neg \psi[\bar{e}/\bar{x}])$, where $\bar{e}$ are fresh constants.
Consider the possible states (1), (2) and (3) of our configuration.
In case (1), if $\psi$ is asserted negatively, then the remainder of the clause $( \neg \psi \vee \neg \bot^\psi \vee \neg \psi[\bar{e}/\bar{x}])$ is ignored.
In the case of (3), the clause is satisfied by $\neg \bot^\psi$ and the solver will again ignore the information contained in $\neg \psi[\bar{e}/\bar{x}]$.

More interestingly, in the case of (2), the SAT-solver must find a satisfying assignment for $\neg \psi[\bar{e}/\bar{x}]$.
In particular, we will see that this will force the DPLL(T) engine to reason about models for our counterexample $\bar{e}$.
Furthermore, in the case where $\neg \psi[\bar{e}/\bar{x}]$ is unsatisifiable, this will signal for the SAT-solver to backjump and assert $\bot^\psi$ negatively as a non-decision literal, or in other words, a counterexample to $\psi$ cannot exist in the current context.
We will see that this will allow us to answer SAT instead of UNKNOWN in some cases.

\subsection{Instantiation Constants}

We will refer to distinguished free constants $\bar{e}$ as introduced in the previous section as \emph{instantiation constants}.
It is important to note that instantiation constants will have identical logical semantics as free constants of the same sort.
In other words, our scheme assumes no information about the value of an instantiation constant $e$, and uses this terminology as a way of referring to such constants.
In this document, we assume a fixed signature $\Sigma$ of function symbols.
For each quantified formula $\psi$, we define the set of variables $\mathcal{I}( \psi )$, called the instantiation constants of $\psi$.

Define the set $T( \Sigma, X )$ as the set of terms over signature $\Sigma$ and variables $X$.
We will only consider terms containing instantiation constants from at most one quantifier.
For convienience, we will write $T( \Sigma )$ to denote the set $T( \Sigma, \emptyset )$.

For a term $t$, if $FV( t ) \cap \mathcal{I}( \psi ) \neq \emptyset$, then we call $t$ an \emph{instantiation term of} $\psi$. 
Similarly, a literal containing instantiation constants from $\psi$ we will refer to as an \emph{instantiation literal of} $\psi$.
For a context $M$, we define $M^\psi$ as the set of instantiation literals of $\psi$ in $M$.
Similarly, we define the set $M^\emptyset$ as the set of literals in $M$ that do not contain instantiation constants from any quantified formula $\psi$.

\subsection{Counterexample Lemma for Quantified Formulas}

Consider the lemma $( \neg \psi \vee \neg \bot^\psi \vee \neg \psi[\bar{e}/\bar{x}])$, where $\bar{e} = \mathcal{I}( \psi )$.
We will refer to this formula as the \emph{counterexample lemma for $\psi$}.
Informally, this lemma is valid since either $\psi$ is not true or $\psi$ does not have a counterexample.
Note that $\neg \psi[\bar{e}/\bar{x}]$ may contain quantifiers.

{\bf Example 0}
Consider the formula $\psi = \forall x. ( l_1 \vee ( l_2 \vee x = a ) \Rightarrow \neg P( x ) )$.
Its counterexample lemma after conversion to CNF is $( \neg \psi \vee \neg \bot^\psi \vee \neg l_1 ) \wedge ( \neg \psi \vee \neg \bot^\psi \vee l_2 \vee e = a ) \wedge ( \neg \psi \vee \neg \bot^\psi \vee P( e ) ) $, where $e = \mathcal{I}( \psi )$. \\

In Example 0, we have produced three clauses.
The first says that either $l_1$ is false or a counterexample does not exist to $\psi$.
The second says that either $l_2$ is true, a counterexample $\psi[e/x]$ exists such that $e = a$, or a counterexample does not exist to $\psi$. 
Similarly, the third says that either a counterexample $\psi[e/x]$ exists such that $P( e )$, or one does not exist.

\subsection{Counterexample $\forall$-Inst}

The counterexample lemma for a quantified formula $\psi$ can be used within the DPLL(T) framework.
The following rule adds the counterexample lemma $\forall \bar{x}. \varphi[ \bar{ x } ]$ to $F$, introducing $\bar{e}$ as the instantiation constants of $\psi$.
This rule represents the central idea behind our approach: \\

\noindent Counterexample $\forall$-Inst: \\

$M \parallel F \Longrightarrow M \parallel F, (\neg \forall \bar{x}. \varphi[ \bar{x} ] \vee \neg \bot^{\forall \bar{x}. \varphi[ \bar{x} ]} \vee \neg \varphi[ \bar{ e }/\bar{x} ])$, if   
$\begin{cases}
  \forall \bar{x}. \varphi[ \bar{ x } ] \in M \\
  \bar{ e } = \mathcal{I}( \forall \bar{x}. \varphi[ \bar{ x } ] ) \\
\end{cases}$ \\

Let us again consider Example 0.
By applying Counterexample $\forall$-Inst to $\psi$, we will produce three clauses $C_1, C_2, C_3$ after CNF-conversion:

$C_1 : ( \neg \psi \vee \neg \bot^\psi \vee \neg l_1 )$,

$C_2 : ( \neg \psi \vee \neg \bot^\psi \vee l_2 \vee e = a )$, and

$C_3 : ( \neg \psi \vee \neg \bot^\psi \vee P( e ) )$.

Say we force the SMT solver to assert $( \bot^\psi )^d$.
It can be shown that the default behavior of DPLL(T) is desirable for reasoning about clauses containing counterexample literals and literals with instantiation constants.

Let us first consider when we are in a state $M, \psi, ( \bot^\psi )^d, N \parallel F$, were $\psi$ has been asserted as a non-decision literal and its counterexample literal has been decided upon positively.
In the case that $l_1$ is asserted positively (possibly as a decision) in $M = M_1, l^{(d)}_1, M_2$, we have that $C_1$ is falsified and we will backjump to the state $M, \psi, \neg \bot^\psi \parallel F$.
This corresponds to saying that a counterexample cannot exist to $\psi$ in the context $M$ where $l_1$ is true.

In the case that $l_1$ is not asserted in $M$, we will apply Unit Propagation to $C_1$ and arrive in the state $M, \psi, ( \bot^\psi )^d, \neg l_1$ $\parallel F$.
This corresponds to saying that $l_1$ must be false if a counterexample to $\psi$ exists.
Note here that we are preferring to constrain ourselves to states in which a counterexample may occur.
This makes sense, both semantically since we have decided that a counterexample may exist (i.e. $( \bot^\psi )^d$), and operationally since the DPLL(T) will reach a non-terminating state if it cannot prove that a counterexample exists.

%Otherwise, if $l_1^d$ had been asserted positively as a decision in $N$, $C_1$ is falsified and conflict analysis would proceed in the standard way to backjump to a state of the form $M, \psi, \neg( \bot^{\neg \varphi} )^d, N', \neg l_1 \parallel F$ or $M, \psi, \neg( \bot^{\neg \varphi} )  \parallel F$.
%In the former case, we have determined that some decision in $N$ has led us to require $l_1$ to be true thereby conflicting with our decision that a counterexample exists.
%In the latter case, we have determined that assuming a counterexample exists means that $l_1$ must be true and thus a counterexample cannot exist.

%Now consider the case where we are in a state $M, \psi^d, \neg( \bot^{\neg \varphi} )^d, N  \parallel F$ where now $\psi$ has been asserted as a decision literal.

%The cases here are identical with one notable exception.
%Take the case where we have encountered a conflict and backjumped to the state $M, \psi^d, \bot^{\neg \varphi} \parallel F$, that is, we know that $\psi$ does not have a counterexample.
%Note the lemma $((\bot^\psi) \vee \psi)$, that is, either $\psi$ has a counterexample or $\psi$ holds.
%We can apply Backjump with $C' \vee l' = \neg ( \bot^\psi) \vee \psi$ to arrive at the state $M, \psi \parallel F$.
%Note, however that this lemma should not be added $F$, as it is exactly what we \emph{do not} want to tell the SAT-solver, as it encodes the trick of our approach.

The analysis for $C_2$ and $C_3$ are as expected, where now the DPLL(T) engine may give partial truth assignments to $l_2$, $e = a$ and $P( e )$, which later may be useful for determining instantiations.
Note in the context $M, \psi, ( \bot^\psi )^d, \neg l_2$, the literal $e = a$ will be unit propagated within $C_3$, thereby signalling that $\psi[a/x]$ is the \emph{only} instantiation we need to try in such a context.

\begin{comment}
We define the following invariant for DPLL(T): \\

{\bf Invariant 1}:
For all DPLL(T) states $M \parallel F$, the only instance of literal $\bot^\psi$ in $F$ occur in clauses $C_1 \ldots C_n$ such that $C_1 \ldots C_n$ is logically equivalent to $( \neg \psi \vee \neg \bot^\psi \vee \neg \psi[\bar{e}/\bar{x}] )$ where $\bar{e} = \mathcal{I}( \psi )$.

It can be shown that counterexample $\forall$-Inst maintains Invariants 1.
Also note that since counterexample literals $\bot^\psi$ have no meaning apart from representing boolean values, no lemma added to $F$ by $T$-Learn will violate Invariant 1.
\end{comment}

\subsection{Enhancements for DPLL(T) Rules}
\label{sec:enhance-dpllt}

First, let us revisit the rule for $\forall$-Inst.
Note that we may restrict this rule to only be applicable to formulas $\forall \bar{x}. \varphi[ \bar{ x } ]$ in cases where a counterexample can exist to $\forall \bar{x}. \varphi[ \bar{ x } ]$.
Such cases can be easily recognized by checking if $\neg \bot^\psi$ is asserted negatively in the current context.

\begin{comment}
Such cases can be easily recognized due to the following theorem:

\begin{thm}
For all DPLL(T) states of the form $M, \neg \bot^\psi \parallel F$, if no literal $l \in M^\psi$ is asserted as a decision, then $M \models_T \psi[\bar{t}/\bar{x}]$ for all $\bar{t}$, or in other words, $\psi$ is valid in the context $M$.
\end{thm}
\begin{proof}
Assume we have a DPLL(T) state $M, \neg \bot^\psi \parallel F$, where $\neg \bot^\psi$ is asserted as a non-decision literal.

Consider the case where $\neg \bot^\psi$ was asserted by unit-propagation.
Since $\psi$ is in $M$, by Invariant 1, it must be the case that $M \models \psi[\bar{e}/\bar{x}]$.
Since no literal $l \in M^\psi$ is asserted as a decision, we can construct an explanation $N \subseteq M'$ such that $N \models \psi[\bar{e}/\bar{x}]$ and $N$ does not contain $\bar{e}$.
Since $\bar{e}$ do not occur in $N$, we have $N \models \psi[\bar{t}/\bar{x}]$ for all vectors of terms $\bar{t}$, and therefore $M \models \psi[\bar{t}/\bar{x}]$ as well.

Consider the case where $\neg \bot^\psi$ was asserted due to a backjump.
The reasoning here is similar, where now a conflict was discovered for a clause of the form $( \neg \psi \vee \neg \bot^\psi \vee l_1[\bar{e}] \vee \ldots \vee l_n[\bar{e}])$, where $\neg l_1[\bar{e}] \wedge \ldots \wedge \neg l_n[\bar{e}] \Rightarrow \psi$.
If no instantiation literal $l$ of $\psi$ is asserted as a decision literal in $M$, we construct an explanation as before to show $\psi$ is valid in $M$.
$\Box$
\end{proof}

Accordingly, we wish to use a search strategy in which no instantiation literal $l$ of $\psi$ should be asserted as a decision when $\neg \bot^\psi$ is not asserted.
This scheme may be enforced within the core of the SAT solver when chosing a decision literal.
When the SAT solver decides on an instantiation literal $l$ of $\psi$, it checks if a value has been given to $\neg \bot^\psi$.
If it has not, then it chooses another literal to decide upon.
This is discussed in more detail in Section~\ref{sec:sat-add}.
\end{comment}

Our updated rule for $\forall$-Inst becomes the following: \\

\noindent $\forall$-Inst (Counterexample Restricted): \\

$M \parallel F \Longrightarrow M \parallel F, (\neg \forall \bar{x}. \varphi[ \bar{ x } ] \vee \varphi[ \bar{ s }/\bar{x} ])$, if   
$\begin{cases}
  \forall \bar{x}. \varphi[ \bar{ x } ] \in M, \bar{ s } \in T( \Sigma ), \\
  \bot^{\forall \bar{x}. \varphi[ \bar{ x } ]} \text{ is not asserted negatively }\\
  \text{ \ \ \ as a non-decision literal in $M$ } \\    
\end{cases}$ \\

We also require that no terms used to instantiate a quantifier contain instantiation constants.

The restricted form for this rule is helpful when trying to establish a satisifiable instance of a formula involving quantifiers.
The following example shows a simple instance where the solver can return SAT by determining that a counterexample cannot exist to a universally quantified formula in a particular context. \\

{\bf Example 1}
Say we wish to determine the satisifiability of the set of formulas $S = \{ a = b, (\psi :) \forall x. ((f(x) = a \wedge f(x) \neq b) \Rightarrow l) \}$.
After two applications of Unit Propagation, we arrive in the DPLL(T) state $( a = b ), \psi \parallel S$.
After using Counterexample $\forall$-Inst for $e = \mathcal{I}( \psi )$, our state becomes $( a = b ), \psi \parallel (S':) S \cup \{ (\neg \psi \vee \neg \bot^\psi \vee f( e ) = a), (\neg \psi \vee \neg \bot^\psi \vee f( e ) \neq b)), (\neg \psi \vee \neg \bot^\psi \vee \neg l) \}$.
Say the solver decides that $\psi$ has a counterexample, and our state becomes $( a = b ), \psi, (\bot^\psi)^d \parallel S'$. 
After unit propagation our state becomes $\ldots, f( e ) = a, f( e ) \neq b \parallel S'$, and we encounter the EUF theory conflict $a = b, f( e ) = a, f( e ) \neq b \models \bot$.
After conflict analysis, we will backtrack to the state $( a = b ), \psi, \neg \bot^\psi \parallel S'$, and now notice that all clauses in $S'$ are satisfied and $\forall$-Inst does not apply to $\psi$.
The solver answers SAT. \\

Here, we have determined $S$ is satisfiable by noting that any model where $a = b$ is true also satisfies $\psi$ for all possible values for $x$.
One can also view this scenario as determining that the axiom $\psi$ is not applicable in the context where $a = b$.

We say a DPLL(T) state $M \parallel F$ is \emph{candidate-satisifiable} if all clauses in $F$ are satisified and $M$ is $T$-consistent.
We say a quantified formula $\psi \in M$ is \emph{counterexample-active} in $M \parallel F$ if Counterexample $\forall$-Inst has been applied to $\psi$ and $(\bot^\psi)^d \in M$.

\begin{thm}
\label{thm:cerep}
Given a candidate-satisifiable DPLL(T) state $M \parallel F$ and a quantified formula $\psi$ that is counterexample-active in $M$, we have that $M \models \neg \psi[\bar{e}/\bar{x}]$, where $\bar{e} = \mathcal{I}( \psi )$.
\end{thm}

\subsection{Learned Lemmas Containing Instantiation Constants}

It is also important to note that learned lemmas can involve instantiation constants.
In Example 1, after the theory conlifct, we could have added the lemma $( f( e ) \neq a \vee f( e ) = b \vee a \neq b )$ to $S'$.
For a larger example, this lemma may potentially be useful in pruning the search space of subsequently when searching for a counterexample to $\psi$.

\begin{comment}
It is also important to note that learned lemmas can involve instantiation constants.
In this example, after the theory conlifct, we could have added the lemma $(\varphi_1 : ) ( f( e ) \neq a \vee f( e ) = b \vee a \neq b )$ to $S'$.
In this case, we may apply Decide to come to the state $( a = b ), \psi, (\neg \bot^\psi), (f( e ) \neq a)^d \parallel S' \cup \varphi$, where again all clauses are satisfied, and the solver answers SAT in the same manner.

However, note that the lemma $\varphi_1$ is only useful in contexts in which $\psi$ is asserted.
In other words, the solver should not be searching for values of counterexamples to quantified formulas $\psi$ when $\psi$ is not asserted.
We will see in Section~\ref{sec:implementation} a recommended implementation for which this concern is addressed.
[do this: do these lemmas pollute the DPLL(T) space?  When should we forget them?  Should we give them to minisat?]
[do this: examine elaborating lemmas involving instantiation constants as being lemmas involving universal statements, justify as well]
\end{comment}

\section{Quantifier Instantiation Using Instantiation Constants}

In this section, we describe theory-specific methods for determining relevant instantiations using information we have deduced about instantiation constants $\bar{e}$ within a theory solver.

We begin with the following definitions:
An instantiation constant $e$ is \emph{solved in $M$} if $e$ does not exist in $M$, or there exists a concrete ground term $s$ such that $M \models_T (e = s)$.
An instantiation constant $e$ is \emph{unsolved in $M$} otherwise.
%Similarly, a term $t$ is \emph{unsolved in $M$} if it contains instantiation constants that are unsolved in $M$; a term $t$ is \emph{solved in $M$} otherwise.
%Note that concrete ground terms $t$ are solved for all $M$.
If $e$ is solved, we define $rep_M( e )$ as the concrete ground representative term existing in the same equivalence class as $e$ if one exists, or a fresh constant otherwise.
Given a quantified formula $\psi$ is \emph{counterexample-solved in $M$} if and only if $M$ is $T$-consistent and all $e_i \in \mathcal{I}( \psi )$ in $M$ are solved in $M$.

The usefulness of determining whether a quantified formula $\psi$ is counterexample-solved is immediate:  if $\psi$ is counterexample active in candidate satsifiable $M \parallel F$, we know that $\neg \psi[ \bar{e}/\bar{x} ]$ is entailed in our current model.
If we also know that $\bar{e} = \bar{s}$, then we know that the instantiation $\psi[ \bar{s}/\bar{x} ]$ must be \emph{unsatisfiable} in the current state.

\begin{thm}
\label{thm:instready}
Given a candidate-satisifiable DPLL(T) state $M \parallel F$, for all quantified formula $\psi$, if $\psi$ is counterexample-active for $\bar{e} = \mathcal{I}( \psi )$ and counterexample-solved in $M$, then $\psi[rep_M( \bar{e} )/\bar{x}]$ is $T$-unsatisfiable in $M$.
\end{thm}
\begin{proof}
Assume $\psi$ is counterexample-active in $M \parallel F$ and counterexample-solved in $M$.
By Theorem~\ref{thm:cerep}, we have that $M \models \neg \psi[\bar{e}/\bar{x}]$.
Since $rep_M( e ) = e$ for all $e \in M$, we know that $M \models \neg \psi[rep_M( \bar{e} )/\bar{x}]$ and thus $\psi[rep_M( \bar{e} )/\bar{x}]$ is $T$-unsatisfiable in $M$. $\Box$
\end{proof}

\ \\ 

\begin{comment}
\begin{cor}
\label{cor:instready}
Given a candidate-satisifiable DPLL(T) state $M \parallel F$, for all quantified formula $\psi \in M$,
if $\psi$ is counterexample-active in $M \parallel F$ and solved in $M$, then the instantiation clause $( \neg \psi$ $\vee$ $\varphi[rep_M( \bar{e} )/\bar{x}])$ has not been added to $F$.
\end{cor}
\begin{proof}
The proof is immediate, noting that by Theorem~\ref{thm:instready}, $( \neg \psi \vee \varphi[rep_M( \bar{e} )/\bar{x}])$ is $T$-unsatisifiable in $M$, and therefore cannot be satisfied in $M \parallel F$. $\Box$
\end{proof}
Corollary~\ref{cor:instready} states that if we can find such an instantiation, then it has not yet been applied.
This fact guarentees that no redundant instantiations are used in certain instantiation schemes.
\end{comment}

In other words, Theorem~\ref{thm:instready} states that if we can find a state $M$ in which we have solved for values of all instantiation constants for $\psi$, we can construct an instantiation for $\psi$ that is guarenteed to lead to a conflict in $M$.
While checking if a quantified formula $\psi$ is solved is straightforward and for many theories can be done in nearly constant time, we should expect recognition of such cases to be rare.

More generally, a theory-specific procedure for quantifier instantiation is interested in finding values for our counterexample such that each instantiation literal of $\psi$ in $M$ (that is, each literal in the set $M^\psi$) is entailed.
If we are able to do so, then we have found an instantiation that \emph{falsify} literals contained in the body of $\psi$, and we again have a similar guarentee for constructing an instantiation that leads to a conflict.
Note the following definition.

\begin{definition}[E-induced]
Say we are in a candidate satisfiable DPLL(T) state $M \parallel F$, and $\psi$ is counterexample-active for $\bar{e} = \mathcal{I}( \psi )$.
We say \emph{$\psi$ is $E$-induced in $M$} if and only if $M \backslash M^\psi, E \models M^\psi$, where $E$ is a set of equalities of the form $\bar{e} = \bar{s}$, and $M^\psi \subseteq M$ are the instantiation literals of $\psi$.
\end{definition}

Futhermore, we say a literal \emph{$L$ is $E$-induced in $M$} if and only if $M \backslash L, E \models L$ where $L \in M^\psi$.

\begin{thm}
\label{thm:einduce}
Given a candidate-satisifiable DPLL(T) state $M \parallel F$, for all quantified formula $\psi$, if $\psi$ is counterexample-active for $\bar{e}$, and $\psi$ is $\bar{e} = \bar{s}$-induced in $M$, then $\psi[\bar{s}/\bar{x}]$ is $T$-unsatisfiable in $M$.
\end{thm}
\begin{proof}
Consider the quantified formula $\psi$, where $\psi$ is counterexample-active for $\bar{e}$ and $\bar{e}=\bar{s}$-induced in $M$.
By Theorem~\ref{thm:cerep}, we have that (1) $M \models \neg \psi[\bar{e}/\bar{x}]$.
Say $M^\psi \subseteq M$ are the instantiation literals of $\psi$.
By the defintion of $E$-induced, we have that $M \backslash M^\psi, \bar{e}=\bar{s} \models_T M^\psi$, and thus $M \backslash M^\psi \models_T (M^\psi)[\bar{s}/\bar{e}]$.
Together with (1), this implies that $M \backslash M^\psi \models_T \neg \psi[\bar{s}/\bar{x}]$, and thus $\psi[\bar{s}/\bar{x}]$ is $T$-unsatisfiable in $M$.
$\Box$
\end{proof}

\ \\ 

This theorem gives a second condition for finding instantiations that are guarenteed to lead to conflicts.
We will see theory-specific methods for determining values for $\bar{s}$ that E-induce quantifiers $\psi$.
Again, in most cases, we will not be able to find such a $\bar{s}$.
In these cases, heuristics will be used to determine $\bar{s}$ such that a maximal number of instantiation literals of $\psi$ are $\bar{e} = \bar{s}$-induced in $M$.

\subsection{Quantifier Instantiation for EUF}

A method for quantifier instantiation in EUF is presented here, which uses information that is asserted as a result of searching for satisifying assignments to the negated bodies of quantifiers.
Say we are given a quantified formula $\psi$ of the form $\forall x. \varphi[x]$ where $x$ is of an uninterpretted sort.
We will search for a satisfying assignment to $\neg \varphi[e]$, and use information asserted about $e$ a basis for determining what values should be used for $x$ to instantiate $\psi$.
The EUF theory solver will process equalities and disequalities between both terms containing instantiation constants and those without.
Since instantiation constants have identical logical semantics to non-instantiation constants, equalities between terms containing instantiation constants may be treated identically, that is, the EUF theory solver is used as is.

Say the equality $t[e/x] = s$ is asserted in the current context $M$.
The goal of this approach will be to find a ground term $g$ such that $M \models_T t[g/x] = s$ has maximum likelihood to hold.
If $M \models_T t[g/x] = s$ for some $g$, then $g$ is a strong candidate for instantiating $\psi$ in the current context.
On the other hand, if $M \models_T t[g/x] \neq s$, then $g$ is useless as an instantiation in the current context with respect to $t[e/x] = s$.
Otherwise if $t[g/x] = s$ is satisifiable in $M$, then $g$ is potentially useful as an instantiation in the current context.

In terms of $E$-matching, this approach treats terms containing instantiation constants as triggers for instantiation.
In addition however, it also takes into consideration entailed equalities and disequalities between such triggers.
This enables a powerful search method for determining relevant instantiations, as well as a criteria for judging the relevance of instantiations that are produced.
For the former, we can imagine an approach in which we first search only the equivalence class of $t[e/x]$ for another term of the form $t[g/x]$, and if none can be found, search the remainder of the concrete ground terms existing in the current context.
For the latter, we may filter instantiations $g$ if, for example, $e = g$ is unsatisifiable in the current context.

Our approach for quantifier instantiation for EUF will be divided into multiple iterations, where on each subsequent iteration, less restrictions are imposed upon the instantiations that are generated.
On the final iteration, our approach will be roughly equivalent to E-matching, where all triggers $t[\bar{e}]$ are matched against all concrete ground terms $g$.
We begin our discussion by introducing necesary terminology.
We first describe how to determine if a literal is induced by a set of equalities between instantiation constants and concrete ground terms.

Say we have a literal of the form $t[\bar{e}/\bar{x}] \sim s$ in $M$, and we wish to find a set of equalities of the form $\bar{e} = \bar{g}$ (we will refer to this as a \emph{unifier}) that are sufficient to show that $t[\bar{e}/\bar{x}] \sim g$ must be true.
Note the subtle difference between this and E-matching.
In E-matching, we are searching for a substitution $\bar{g}$ such that $t[\bar{g}/\bar{x}]$ is syntactically equivalent to $s$ modulo our set of ground equalities.
In this approach, we need only consider the equalities necessary to force $t[\bar{e}/\bar{x}]$ to be equal to $s$, possibly using equalities between triggers already existing in $M$.

Consider the following illustrative example.
Say we have the quantifier $\psi$ of the form $\forall x. (g(x) = a \Rightarrow f( x, g( x ) ) \neq f( b, a ))$.
After applying Counterexample $\forall$-Inst, we will have the literals $g(e) = a$ and $f( e, g( e ) ) = f( b, a )$ asserted in the current context for $e \in \mathcal{I}( \psi )$.
Note that $e = b$ suffices to show that $f( e, g( e ) ) = f( b, a )$ in this example, suggesting that we may wish to use $b$ to instantiate $\psi$.
In a basic implementation of E-matching, $f( x, g( x ) )$ and $f( b, a )$ do not E-match.

Let us first consider equalities of the form $t = g$, where $t$ contains instantiation constants from $\psi$ and $g \in T( \Sigma )$.
We are interested in finding a unifier $\bar{e} = \bar{s}$ that induces the equality $t = g$.
The following method $e\_ind$ computes an over-approximation of the set of such unifiers:

\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |e\_ind|(t,g,M,\psi) \BODY
  \IF FV( t ) \cap \mathcal{I}( \psi ) = \emptyset, FV( g ) \cap \mathcal{I}( \psi ) \neq \emptyset,
      \text{ or } M \models_T t \neq g \THEN
    \RETURN \emptyset;
  \ELSEIF t \text{ is inst. constant } \THEN
    %\IF M \models_T t = g' \text{ where } g, g' \text{ are distinct }
    %   \RETURN \emptyset
    %\ELSE
    \RETURN \{ \{ t = rep_M(g) \} \};
  \ELSEIF t, g \text{ are $f( \bar{t_a} )$, $f( \bar{g_a} )$ } \THEN
    S := \{ \emptyset \};
    \DOFOR \text{each } t_i \text{ in } \bar{t_a} 
      \IF M \not\models_T t_i = g_i
        S' := e\_ind\_mod( t_i, g_i, M, \psi );
        S := merge( S, S' );
      \FI
    \ENDFOR
    \RETURN S;
  \ELSE
    \RETURN \emptyset;
  \FI
\ENDPROC
\end{program}
\end{minipage}
\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |e\_ind\_mod|(t,g,M,\psi) \BODY
  S := \emptyset;
  \DOFOR \text{each } g_i = g
    S := S \cup e\_ind( t, g_i, M,\psi );
  \ENDFOR
  \RETURN S;
\ENDPROC
\end{program}
\begin{program}
\PROC |merge|(S_1,S_2) \BODY
  S'' := \emptyset;
  \DOFOR E_1 \in S_1, E_2 \in S_2
    \IF E_1 \text{ and } E_2 \text{ are compatible }
      S'' := S'' \cup \{ E_1 \cup E_2 \}
    \FI
  \ENDFOR
  \RETURN S'';
\ENDPROC
\end{program}
\end{minipage}

\ \\

The method $e\_ind(t,g,M,\psi)$ is intended to be applied where $t$ contains instantiation constants from $\psi$ and $g$ is a concrete ground term.
If these preconditions are not met or if $t$ is disequal from $g$, the method returns the empty set.
In the case that $t$ is an instantiation constant, the method returns the set containg a single unifier containing $t = rep_M( g )$.
If $t$ is of the form $f(\bar{t})$ and g is of the form $f(\bar{g})$, then the method scans each pair of arguments $t_i, g_i$.
If the arguments $t_i$ and $g_i$ are not entailed to be equal, the method computes, modulo equality, a set of unifiers $S'$ such that $t_i = g_i$ is induced in $M$.
For each set $S'$ produced in this way, it merges this set with $S$ using the method $merge$.
This method pairwise combines $S_1$ and $S_2$ to form the set $S''$.
For each pair $E_1 \in S_1$, $E_2 \in S_2$, if $E_1$ and $E_2$ are compatible, that is, there does not exist an equality $e = t_1$ in $E_1$ and $e = t_2$ in $E_2$ and $t_1$ is not syntactically equivalent to $t_2$, then the union of $E_1$ and $E_2$ is added to $S''$.
Otherwise, if $t$ is of the form $f(\bar{t})$ and $g$ is not of the form $f( \bar{g})$ for some $\bar{g}$, the method $e\_ind(t,g,M, \psi)$ returns the empty set, or in other words $t$ and $g$ do not match.

\begin{comment}

\begin{lemma}
\label{lem:e-ind}
For each $E \in e\_ind(t,g,M,\psi)$, we have that $M \backslash t = g, E \models_T t = g$
\end{lemma}
\begin{proof}
The proof is by induction on the structure of $t$, with the induction hypothesis $M \backslash t = g, E \models_T t = g$.
If $t$ is an instantiation constant, then clearly $M \backslash t = g, t = rep( g ) \models_T t = g$.

Otherwise, the only other relevant case to consider is when $t$ is of the form $f( \bar{t_a} )$ and $g$ is of the form $f( \bar{ g_a } )$ (for all other cases, $e\_ind$ returns the empty set).
By congruence, it suffices to show for each $E$ in the constructed set $S$, we have that all the arguments of $t$ and $g$ are $E$-induced in $M$, or in other words $M \backslash t = g, E \models_T t_1 = g_1 \wedge \ldots \wedge t_n = g_n$.

Say we have constructed a set of equality sets $S_{i-1}$ such that $M \backslash t = g, E \models t_1 = g_1 \wedge \ldots \wedge t_{i-1} = g_{i-1}$ for each $E \in S_{i-1}$.
Our goal is to show that $e\_ind$ constructs an $S_i$ on the $i^{th}$ iteration such that for each $E \in S_i$, $M \backslash t = g, E \models_T t_1 = g_1 \wedge \ldots \wedge t_{i-1} = g_{i-1} \wedge t_i = g_i$.
In the case that $M \models_T t_i = g_i$, then $S_i$ is equal to $S_{i-1}$ and the statement holds immediately.
In the case that $M \not\models_T t_i = g_i$, then we may construct a set $S'$. 
Note that by our induction hypothesis, $M \backslash t_i = g_i, E \models_T t_i = g_i$ for each $E \in S'$.
We take $S_i$ to be the merge of $S_{i-1}$ and $S'$.
Since each $E \in S_i$ contains all equalities from some $E_1 \in S_{i-1}$ and some $E_2 \in S'$, we have that $M \backslash t = g, E \models_T t_1 = g_1 \wedge \ldots \wedge t_{i-1} = g_{i-1} \wedge t_i = g_i$ for each $E \in S_i$. $\Box$
\end{proof}
\end{comment}

In this section, we will be interested in classifying which pairs of terms may potentially be $E$-induced to be equal.
A term $f( t_1, \ldots, t_n )$ is \emph{equality-independent from term $s$ in $M$} if either (a) $s$ is of the form $g( s_1, \ldots s_m )$, or (b) $s$ is of the form $f( s_1, \ldots s_n )$, and $M \models_T t_i \neq s_i$ for some $i$.
Terms that are not equality independent we will call \emph{equality-dependent}.
Define the set $Q^t_M$ as the set of non-instantiation terms in $M$ that are equality dependent with $t$.
We say that $t$ is \emph{unmatchable in} $M$ if and only if $Q^t_M$ is empty, and \emph{matchable in} $M$ otherwise.
A literal $t \sim s$ is unmatchable in $M$ if either $t$ or $s$ is unmatchable in $M$, and matchable in $M$ otherwise.
We say $t \sim s$ is \emph{literal-matched in} $M$ if there exists a $g \in Q^t_M$ and $h \in Q^s_M$ such that $M \models_T g \sim h$.
%Note that all literals not containing instantiation constants that are entailed in $M$ are literal-matchable.

\begin{comment}
%For a pair of equality-dependent terms $t,s$ of the form $f( t_1, \ldots, t_n )$, $f( s_1, \ldots s_n )$, define $NeqArgs_M( t, s )$ to be equal to the number of pairs $t_i, s_i$ such that $M \not\models t_i = s_i$.
%For a quantified formula $\psi$, a term $f( t_1, \ldots, t_n )$ is \emph{equality-compatible with term $s$ in $M$} if and only if $s$ is of the form $f( s_1, \ldots s_n )$ and $M \models_T t_1 = s_1 \wedge \ldots \wedge t_n = s_n$.
%A pair of terms $t, s$ is \emph{equality-ambiguous} if $t$ is neither equality-compatible nor equality-independent from $s$.

Given a term $t \in T( \Sigma, \mathcal{I}( \psi ) )$, we say that $t$ is \emph{unmatchable} in $M$ if all terms $t'$ in $M$ are equality-independent from $t$.
A literal $t \sim s$ is unmatchable if either $t$ or $s$ is unmatchable.
Otherwise, for a literal $t \sim s$, consider the case when $s$ does not contain instantiation constants.
We will be interested in finding a corresponding concrete ground term, call it $t_{\sim s}$, that represents the best match for $t$ with regard to literal $t \sim s$.
We require that $t$ and $t_{\sim s}$ are equality-dependent.
Formally, define $t_{\sim s}$ as the term in $M$ that is maximal with respect to the following metrics in descending order of importance: 

(1) $M \not\models_T t_{\sim s} \not\sim s$, 

(2) $M \models_T t_{\sim s} \sim s$,

(3) $t \sim t_{\sim s}$ is $E$-induced in $M$ for some $E$,

(4) minimum value of $NeqArgs_M( t, t_{\sim s} )$.

In the case that we have a matchable literal $t \sim s$ where both $t$ and $s$ contain instantiation constants, we define $t_{\sim s}$ and $s_{\sim t}$ similarly.
In the case that $M \models_T t_{\sim s} \sim s_{\sim t}$, we say that $t \sim s$ is \emph{literal-matched}, that is, a candidate match at the literal level has been found.
\end{comment}

\subsubsection{E-Matching Using Equalities and Disequalities Between Triggers}

We now describe a method for determining instantiations for a quantified formula $\psi$ of the form $\forall \bar{x}. \varphi[\bar{x}]$, where $\bar{x}$ are of uninterpretted sorts.
We are interested in finding an instantiation $\bar{s}$ for $\psi$ in a candidate-satisfiable DPLL(T) state $M \parallel F$, where $\psi$ is counterexample-active in $M$ for $\bar{e}$.
Our method for quantifier instantiation in EUF will consist of five iterations, where in each iteration we relax the constraints we place on adding lemmas to $F$.
The method terminates when an iteration successfully adds a lemma to $F$, or when the last iteration has completed.

\paragraph{First Iteration: $\psi$ is Counterexample-Solved}

On the first iteration of quantifier instantiation for $\psi$, we check to see if each $e_i$ in $\bar{e}$ that is present in $M$ exists in the same equivalence class as a concrete ground term $rep_M(e_i)$.
For each $e_i$ not present in $M$, we pick an arbitrary concrete ground term if one exists, or a fresh constant otherwise.
If we can construct a vector of terms of this form, we return only this instantiation.
By Theorem~\ref{thm:instready}, this instantiation is \emph{guarenteed} to generate a conflict if all literals in $M^\psi$ belong to the equality and uninterpretted functions theory.

\paragraph{Second Iteration: $\psi$ is E-Induced}

If $\psi$ is not solved, we determine whether each instantiation literal $L$ of $\psi$ can be induced by a unifier $\bar{e} = \bar{s}$.
The following method generates a set of equality sets $S$ for a literal $L$ such that $L$ is $E$-induced in $M$ for each $E$ in $S$:

\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |e\_ind\_lit|(t \sim s,M,\psi) \BODY
  S := \emptyset;
  \IF FV( t ) \cap \mathcal{I}( \psi ) \neq \emptyset \THEN
    \IF FV( s ) \cap \mathcal{I}( \psi ) = \emptyset \THEN
      \DOFOR \text{each $g$, where } M \models_T g \sim s
        S := S \cup e\_ind( t, g, M, \psi );
      \ENDFOR
    \ELSE
      \DOFOR \text{each } g, h \text{ where } M \models_T g \sim h
        S := S \cup merge( e\_ind( t, g, M, \psi ), e\_ind( s, h, M, \psi ) );
      \ENDFOR 
    \FI
  \FI
  \RETURN S;
\ENDPROC
\end{program}
\end{minipage}

\ \\

When $L$ is an equality or disequality of the form $t \sim s$, where $t$ contains instantiation constants from $\psi$ and $s$ is a concrete ground term, we return the union of $e\_ind( t, g, M, \psi )$ for each term $g$ such that $g \sim s$.
Otherwise if $s$ also contains instantiation constants from $\psi$, we wish to find pairs of terms $g$ and $h$ such that $g \sim h$ and $t = g$ and $s = h$ are induced by sets of unifiers.
If this is the case, we merge these sets and add them to our overall set $S$.
The following method describes the overall procedure used in the second iteration:

\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |generate\_lemmas\_2|(M, \psi) \BODY
  S := \{ \emptyset \};
  \DOFOR \text{each } t \sim s \in M^\psi
    S := merge( S, e\_ind\_lit( t \sim s, M, \psi ) );
  \ENDFOR
  \text{add instantiations } \{ E^c \mid E \in S \}
  \RETURN;
\ENDPROC
\end{program}
\end{minipage}

\ \\

The method $generate\_lemmas\_2$ constructs a set of unifiers $S$ by merging sets that induce each $t \sim s \in M^\psi$.
In terms of E-matching, merging unifiers over multiple literals serves a similar purpose as \emph{multi-triggers}.
For each $E \in S$, we construct an instantiation $E^c$ where $E^c$ is the unifier containing unifier $E$ as well as equalities $e_i = c_i$ for each $e_i \in \mathcal{I}( \psi )$ not existing in $E$, where $c_i$ is a fresh constant.

\begin{comment}
\begin{thm}
\label{thm:eind-ready}
Given a candidate-satisifiable DPLL(T) state $M \parallel F$, and a formula $\psi$ of the form $\forall \bar{x}. \varphi[ \bar{x} ]$ that is counterexample-active in $M \parallel F$ for $\bar{e}.
For all unifiers $\bar{e} = \bar{s}$ returned by the function $generate\_inst\_2$, we have that $\psi$ is $\bar{e}-\bar{s}$-induced in $M$.
\end{thm}
\begin{proof}
We must show $M \backslash M^\psi, \bar{e} = \bar{s} \models M^\psi$.

\end{proof}
Theorem~\ref{thm:eind-ready} states that if all instantiation literals for $\psi$ are induced by the same equality set $E$, then the corresponding instantiation $E^c$ is guarenteed to lead to a conflict.
\end{comment}

\paragraph{Third Iteration: All Literals of $\psi$ are E-Induced}

If no instantiations are produced on the second iteration, we must determine the reason why our procedure failed.
We could have failed to produce an instantiation for a variety of reasons: a pair of terms $g \sim h$ could not be found to match some literal $t \sim s$, the unifiers for two literals $t_1 \sim s_1$ and $t_2 \sim s_2$ were incompatible, the unifiers for two subterms of $t$ were incompatible, and so on.
Here, we consider quantifiers $\psi$ where all instantiation literals $L_i$ of $\psi$ where $E$-induced in $M$ for some non-empty set of unifiers $S_i$, but we failed to merge the sets $S_1 \ldots S_n$.

\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |generate\_lemmas\_3|(M, \psi) \BODY
  S_1 \ldots S_n;
  \DOFOR \text{each } L_i \in M^\psi
    S_i := e\_ind\_lit( L_i, M, \psi );
    \IF S_i = \emptyset \THEN
      \RETURN;
    \FI
  \ENDFOR
  resolve\_merge( \{ S_1, \ldots, S_n \}, M, \psi )
  \RETURN;
\ENDPROC
\end{program}
\end{minipage}

\ \\

An overview of the procedure used on the third iteration is summarized in the method $generate\_lemmas\_3$.
We produce the set of unifiers that induce each $L_i$, and call the method $resolve\_merge$.
This method constructs relevant splits for determining why we were unable to merge the sets of unifiers $\{ S_1, \ldots, S_n \}$.
Consider the case where $n = 2$ and there exists an $E_1 \in S_1$ and $E_2 \in S_2$ that differ only on the value of one instantiation constant $e_i$, say $e_i = t_1 \in E_1$ and $e_i = t_2 \in E_2$ where $M \not\models_T t_1 = t_2$.
In the case that $M \not\models t_1 \neq t_2$, we may choose to add the splitting lemma $( t_1 = t_2 \vee t_1 \neq t_2 )$ to $M$.
The usefulness of this lemma is two-fold: in the case where $t_1 = t_2$, we are able to merge the unifiers $E_1$ and $E_2$ and will be closer to finding an instantiation that leads to a conflict.
In the case that $t_1 \neq t_2$, we are more likely to force instantiation terms to be unmatchable, in which case we are closer to finding a model.

\paragraph{Fourth Iteration: All Literals of $\psi$ are Literal-Matched}

If some literal is not E-induced, we consider quantifiers where our procedure found a candidate match at the literal level for each instantiation literal.
The following gives an overview of the procedure used on the fourth iteration:

\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |generate\_lemmas\_4|(M, \psi) \BODY
  \DOFOR \text{each } t \sim s \in M^\psi
    \IF t \sim s \text{ is not literal-matchable} \THEN
      \RETURN;
    \FI
  \ENDFOR
  \DOFOR \text{each } t \sim s \in M^\psi
    \IF e\_ind\_lit( t \sim s, M, \psi ) = \emptyset \THEN
      \DOFOR g \in Q^t_M, h \in Q^s_M, \text{ where } M \models_T g \sim h
      	S_t := e\_ind\_lit( t = g, M, \psi );
      	S_s := e\_ind\_lit( s = h, M, \psi );
        \IF S_t \neq \emptyset \text{ and } S_s \neq \emptyset \THEN
      	  resolve\_merge( \{ S_t, S_s \}, M, \psi )
      	\ELSE	
      	  resolve\_match( t, g, M, \psi )
     	  resolve\_match( s, h, M, \psi )
     	\FI
      \ENDFOR
    \FI
  \ENDFOR
  \RETURN;
\ENDPROC
\end{program}
\end{minipage}

\ \\

On this iteration, we are interested in finding why we were not able to $E$-induce individual literals.
We look at candidate match terms $g$ and $h$ with respect to the literal $t \sim s$.
In the case that we were able to induce each of $t$ and $s$ to be equal to their respective matches via the sets of unifiers $S_t$ and $S_s$, then we attempt to determine why these sets did not merge using the method $resolve\_merge$.
Otherwise, if we determine why $t = g$ was not induced using the method $resolve\_match$ and similarly for $s = h$, if applicable.

\paragraph{Fifth Iteration: All Literals of $\psi$ are Matchable}

If the previous iteration failed to add a splitting lemma, we proceed to the fifth iteration.
In this iteration, we process quantifiers $\psi$ such that for each $t \sim s \in M^\psi$, both $t$ and $s$ are matchable.
In other words, there exists a ground terms that are equality dependent to both $t$ and $s$.

\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |generate\_lemmas\_5|(M, \psi) \BODY
  \DOFOR \text{each } t \sim s \in M^\psi
    \IF t \sim s \text{ is unmatchable } \THEN
      \RETURN;
    \FI
  \ENDFOR
  \DOFOR \text{each } t \sim s \in M^\psi
    \IF e\_ind\_lit( t \sim s, M, \psi ) = \emptyset \THEN
      \DOFOR g \in Q^t_M, h \in Q^s_M
        \IF M \not\models_T g \sim h \THEN
          \text{split on } g = h;
        \FI
      \ENDFOR
    \FI
  \ENDFOR
  \RETURN;
\ENDPROC
\end{program}
\end{minipage}

\ \\

This iteration splits on equalities between terms $t$ and $s$ and their corresponding matches, for each literal $t \sim s$ of $\psi$ that are not literal-matched.

\paragraph{Recognizing Other SAT instances}

In the case when the fifth iteration fails to add a lemma, we know that we are close to finding a model that universally satisifies each quantifier.
The idea is that if no matches can be found for some instantiation term $f( \bar{t} )$ of $\psi$, then the interpretation of the symbol $f$ over arguments $\bar{t}$ is unconstrained.
In particular, if we know that $f( \bar{t} )$ is equality-independent from all other terms $f( \bar{ s } )$, we know that the domain of $f( \bar{t} )$ does not overlap with any other constrained term.
Thus, we may by construction give an interpretation explicitly that shows that $f( \bar{ t } ) \sim s$ is always false where $f( \bar{t} ) \sim s$ is required by our counterexample to $\psi$. 
This interprettation is constructed directly by giving an interprettation to a symbol that \emph{falsifies} an instantiation literal for all possible values of $\bar{e}$.
We may then use Model Based Quantifier Instantiation to check whether this interprettation satisifies all active quantifiers.

\ \\

{\bf Example 1}
Consider the set of clauses $S = \{ (\psi_1 :) \ \forall x. G( S( x ), x), (\psi_2 :) \forall xyz. (G(x,y) \wedge G(y,z)) \Rightarrow G(x,z), \neg G( S(S(a)), a) \}$.
Note that $S$ represents a successor function and $G$ represents ``is greater than".  
In other words, this set of clauses says that $a + 2 > a$ is not true for some constant $a$.

After unit propagations and Counterexample $\forall$-Inst, we have the set of assertions $\psi_1$, $\psi_2$, $G( S(S(a)), a)$ = $G( S(e_1), e_1)$ = $G( e_2, e_4 )$ = $\bot$, $G( e_2, e_3 )$ = $G( e_3, e_4 )$ = $\top$, where $\top$ and $\bot$ are the distinguished free boolean constant representing true and false, $e_1 = \mathcal{I}( \psi_1 )$ and $e_2, e_3, e_4 = \mathcal{I}( \psi_2 )$.

Say we wish to perform a round of instantiation for $\psi_1, \psi_2$.
In the first iteration, neither $\psi_1$ or $\psi_2$ are solved.
In the second iteration, we find that $G( e_2, e_4 ) = \top$ is induced by $e_2, e_4 = S(S(a)), a$, but this does not produce an instantiation since $e_3$ is unspecified and a complete equality set cannot be produced for $\psi_2$.
In the third iteration, we find that the term $G( S(e_1), e_1)$ partially matches with the term $G( S(S(a)), a)$ for both $S(a)/e_1$ and $a/e_1$.
This iteration succeeds and adds the instantiation clauses $( \neg \psi_1 \vee \psi_1[S(a)/x])$ and $( \neg \psi_1 \vee \psi_1[a/x])$ to $F$.

After finding a satisfying assignment for these clauses by Unit propagation, we reach a state where $G( S(S(a)), a)$ = $G( S(e_1), e_1)$ = $G( e_2, e_4 )$ = $\bot$, $G( e_2, e_3 )$ = $G( e_3, e_4 )$ = $G(S(S(a)), S(a))$ = $G( S(a), a)$ = $\top$.
Again, neither $\psi_1$ and $\psi_2$ is solved.
In the second iteration, we find that $G( e_2, e_3 ) = \top$ is induced by $e_2,e_3$ = $S(S(a)), S(a)$, and $G( e_3, e_4 )$ is induced by $e_3, e_4$ = $S(a), a$.
During our combination step, we produce the equality set $e_2, e_3, e_4$ = $S(S(a)), S(a), a$ and use these values to instantiate $\psi_2$.
In fact, all instantiation literals from $\psi_2$ are induced by this instantiation, and as a result a conflict is discovered at the top level and the solver answers UNSAT.

\subsection{Quantifier Instantiation for LRA}

A method of quantifier instantiation for linear real arithmetic can be devised analagously as the method in the previous section.
Say we wish to determine instantiations for a quantified formula $\psi$ of the form $\forall \bar{x}. \varphi[\bar{x}]$, where $\bar{x}$ are variables of type $Real$ and $\varphi[\bar{x}]$ is a formula over linear real arithmetic (possibly containing quantifiers).
After searching for a satisifying assignment to $\neg \varphi[\bar{e}/\bar{x}]$, our context will contain constraints of the form $A\ \bar{t} + B\ \bar{e} + c \geq 0$, where $A$ and $B$ are real numeral coefficients and $\bar{t}$ are ground terms.
For each constraint of this form, the idea will be to find a ground term substitution $[\bar{g}/\bar{e}]$ such that $A\ \bar{t} + B\ \bar{g} + c \equiv d$, where $d$ is a constant greater than or equal to $0$.
The idea here is that if we can find such a substitution for $\bar{e}$, then we have found an instantiation that falsifies the corresponding contraint $A\ \bar{t} + B\ \bar{x} + c < 0$ in $\psi$ universally.
Similar as before, we wish to find a single ground term substitution $[\bar{g}/\bar{e}]$ that has this effect for \emph{all} constraints containing $\bar{e}$ asserted in $M$, whereby we are guarenteed to encounter a conflict if all literals existing in $\psi$ belong to linear real arithmetic.

Decision procedures for linear real arithmetic commonly rely on the Simplex procedure, where \emph{slack variables} $s$ are introduced to refer to linear real terms.
We can see this procedure as treating the formula $\Phi$ as a formula of the form $\Phi_A \wedge \Phi'$, where $\Phi_A$ contains equalities between slack variables and linear real terms, and $\Phi'$ contains only elementary atoms of the form $y \bowtie c$, where $y$ is a variable and $c$ is a rational constant.
For example, a formula $a + b \geq 4 \vee a \leq 0$ is considered to be the equisatisfiable formula $s = a + b \wedge ( s \geq 4 \vee a \leq 0 )$.

Let $\bar{z}$ refer to all variables occuring in the converted formula $\Phi_A \wedge \Phi'$.
Note that $\Phi_A$ can be thought of as describing a system of equalities of the form $A \bar{z} = 0$, where $A$ is a $m \times n$ rational matrix, where $m$ is the number of slack variables, and $n$ is the total number of variables $\bar{z}$.
Checking the satisfiability of the formula $\Phi_A \wedge \Phi'$ amounts to finding values for $\bar{x}$ that satisfy:

(1) $A \bar{z} = 0$, and

(2) $l_i \leq z_i \leq u_i$, for all $z_i \in \bar{z}$.

Here, $l_i$ is either a rational constant or $- \infty$, and likewise $u_i$ is either a rational constant or $+ \infty$.
When DPLL(T) reaches a candidate satisfiable state, the simplex tableaux will contain a value for each $\bar{z}$ that satisfies its corresponding upper and lower bounds, call this value $\beta( z_i )$ for each $z_i$ in $\bar{z}$.

We will say $z_i$ is an \emph{instantiation row for $\psi$}, if $z_i \equiv A_i\ \bar{t} + B_i\ \bar{e}$, where $\bar{t}$ are ground terms, $B_i$ is non-zero, and $\bar{e}$ are the instantiation constants for $\psi$.
We are interested in finding a ground term substitution $[\bar{g}/\bar{e}]$ for each instantiation row $i$ for $\psi$, such that $A_i\ \bar{t} + B_i\ \bar{g} \equiv \beta( s_i )$.
The corresponding literal in the instantiated formula $\psi[\bar{g}/\bar{x}]$ is guarenteed to rule out the current assignment for $s_i$.
For example, say we wish to determine if the formula $\psi : \forall x. 2 \cdot c + x > 5$ is satisfiable.
After finding a satisfying assignment to $\neg \psi[e/x]$, we have the row $s_1 = 2 \cdot c + e$, where $- \infty \leq s_1 \leq 5$, and the assignment $\beta( s_1 ) = 0$.
We are interested in producing the term substitution $[-2 \cdot c/e]$, since $2 \cdot c + -2 \cdot c \equiv \beta( s_1 ) = 0$.
In this case, the instantiation $\psi[-2 \cdot c/x]$ produces a conflict.

More generally, we wish to determine a ground term substitution $\bar{g}$ for $\bar{e}$ such that a maximal number of instantiation rows for $\psi$ are induced to be equal to their current assignment. 
First, let us look how we can determine if there exists an instantiation that induces all constraints containing instantiation constants.
For a quantified formula $\psi$, let us say our tableaux has $r$ instantiation rows for $\psi$, which give constraints of the form
\begin{eqnarray}
\displaystyle\bigwedge\limits_{i=1}^r A_i\ \bar{t} + B_i\ \bar{e} & = & 0
\end{eqnarray}
where $\bar{t}$ are ground terms and $\bar{e}$ are the instantiation constants for $\psi$.  
For simplicity of presentation, we assume that the constant term $1$ belongs to $\bar{t}$, and consider the right hand side of each equation equal to zero.
We are interested in producing a ground term substitution of the form
\begin{eqnarray}
\displaystyle\bigcup\limits_{j=1}^m [ s^D_j / e_j ],
\text{where } s^D_j = \displaystyle\sum\limits_{k=1}^n D_{jk} \cdot t_k
\end{eqnarray}
Furthermore, we wish to find values for the $m \times n$ matrix $D$ such that for each row $i = 1 \ldots r$, we have that $A_i\ \bar{t} + B_i\ \bar{s^D} \equiv 0$.
This can be done by finding a satisfying assignment to the following formula:
\begin{eqnarray}
\label{eq:e-ind-lit-lra}
\displaystyle\bigwedge\limits_{i=1}^r \displaystyle\bigwedge\limits_{j=1}^m \displaystyle\sum\limits_{k=1}^n D_{jk} \cdot B_{ik} = -A_{ij}
\end{eqnarray}
If we can construct a satisfying assignment to this formula, then we can construct a substitution $[\bar{s^D}/\bar{e}]$ that universally falsifies each currently asserted literal of $\psi$ belonging to linear real arithmetic that describe our counterexample.
Note that formula (\ref{eq:e-ind-lit-lra}) is a formula in linear real arithmetic, containing a conjunction of $r \cdot m$ equalities over $m \cdot n$ variables, where $r$ is the number of instantiation rows for $\psi$, $m$ is the number of instantiation constants for $\psi$, and $n$ is the number of terms in $\bar{t}$.

\ \\

{\bf Example 2}
Consider the quantified formula $\psi : \forall x y. ((2 \cdot x + y > 4) \vee (y + c > 0))$.
After searching for a counterexample, we will obtain the assertions $2 \cdot e_x + e_y \leq 4$ and $c + e_y \leq 0$.
After finding a model, let us say our model tells us $-4 + 2 \cdot e_x + e_y = 0$ and $c + e_y = 0$.
Define $D$ as the $2 \times 2$ matrix where the rows represent $e_x, e_y$ and the columns represent $c, 1$ respectively.
We wish to determine the satisfiability of the formula $2 \cdot D_{11} + D_{21} = 0$ $\wedge$ $2 \cdot D_{12} + D_{22} = 4$ $\wedge$ $D_{21} = -1$ $\wedge$ $D_{22} = 0$.
After finding the satisfying assignment $\{$ $D_{11} \mapsto \frac{1}{2}$, $D_{12} \mapsto 2$, $D_{21} \mapsto -1$, $D_{22} \mapsto 0$ $\}$ we construct the instantiation $[(\frac{1}{2} \cdot c + 2)/x, -c/y]$.
This instantiation falsifies $\psi$. $\Box$

%Note the following theorem.

%\begin{thm}
%Given a candidate-satisifiable DPLL(T) state $M \parallel F$, and a formula $\psi$ that is counterexample-active in $M \parallel F$ for $\bar{e}$,
%$\ldots$ [do this] $\ldots$
%Then, $\psi$ is $\bar{e} = \bar{s^D}$-induced in $M$.
%\end{thm}
%\begin{proof}
%[do this]
%\end{proof}

Note that since we are determining the satisfiability of a conjunction of $r \cdot m$ equalities over $m \cdot n$ variables, we are guarenteed to find a satisifying assignment when $n \geq r$, or in other words, when the number of instantiation constants is greater than or equal to the number of instantiation rows.
However, in most cases, we should expect cases finding a satisfying assigment to (~\ref{eq:e-ind-lit-lra}) to be rare.
If indeed formula (\ref{eq:e-ind-lit-lra}) is unsatisfiable, then we may wish to find a subset $S$ of $1 \ldots r$ such that 
\begin{eqnarray}
\displaystyle\bigwedge\limits_{i \in S} \displaystyle\bigwedge\limits_{j=1}^m \displaystyle\sum\limits_{k=1}^n D_{jk} \cdot B_{ij} = -A_{ij}
\end{eqnarray}
is satisfiable.  
Similarly, a satisfying assignment to this formula allows us to construct a substitution that universally falsifies a subset of the currently asserted literals of $\psi$ belonging to linear real arithmetic that describe our counterexample.

\paragraph{Relationship to Quantifier Elimination}

[do this]

\subsection{Quantifier Instantiation for LIA}


\section{Additions to SAT solver}
\label{sec:sat-add}

The following three general-purpose features are preferrable to have when handling quantifiers in SMT using the approach described in this document.

\subsection{Require Phase for Decision Literal}

We have introduced a method for reasoning about counterexamples to quantified formulas $\psi$ through the use of counterexample literals $\neg \bot^\psi$.
Recall that this literal operationally has the meaning that ``a counterexample to $\psi$ does not exist."
It is preferrable (although not required for soundness) that $\neg \bot^\psi$ is never asserted positively as a decision.
Doing so is unhelpful:  if we reach a candidate satisfiable state, we cannot answer SAT since the validity of $\psi$ is unproven.
Additionally, such an assertion will cause the solver to ignore information regarding the counterexample $\bar{e} = \mathcal{I}( \psi )$, and limit our ability to recognize useful instantiations.

For the reason, we supplement the SAT solver with the abitility to restrict the polarity for decisions of SAT literals.
This requires at most two bits per SAT variable and a constant time lookup for each decision made.

\subsection{Dependent Decision Literals}

To reason about a counterexample to a quantified formula $\psi$, we have introduced distinguished fresh constants $\bar{e}$, called instantiation constants.
These constants are used to represent which values can possibly falsify $\psi$.

In Section~\ref{sec:enhance-dpllt}, we saw that the value of $\neg \bot^\psi$ can be used to recognize when a quantified formula is valid and answer SAT in certain contexts.
This feature came under the condition that no information about the counterexample to $\psi$ is assumed before we determine that $\psi$ is valid.
Thus, we require that no literals $l$ containing instantiation constants from $\psi$ can be asserted until $\bot^{ \neg \psi }$ has a value.

Thus, we restrict the order in which SAT literals can be chosen for decisions.
For each SAT variable $v$, we store a reference to another SAT variable $v'$ that $v$ is dependent upon.
If the SAT solver chooses to assert $v$ and $v'$ does not have a value, the SAT solver will choose another literal to decide upon.
For our approach to quantifiers, we only require variables that are dependent on at most one literal.
Thus, this feature requires at most a map between SAT variables and a constant time lookup for each decision made.

[do this: determine logistical issues]

\subsection{Flipping Decision Literals}

Our approach for quantifier instantiation in SMT is capable of producing relevant instantiations as well as recognizing certain cases in which a quantifier is valid. 
In this section, we will consider how to proceed in states where a quantified formula $\forall \bar{x}. \varphi[ \bar{x} ]$ is neither valid nor easily shown to be unsatisfiable. \\

{\bf Example 3} 
Say we wish to determine the satisfiability of the set of clauses $S = \{ a = b, (\psi :) \forall x. ((f(x) = c \vee x = a) \Rightarrow x = b) \}$.
After applying Unit Propagation twice, applying Decide on $\neg (\bot^{ \neg \psi })^d$, and applying Counterexample $\forall$-Inst, we obtain the clauses $( \neg \psi \vee \bot^{ \neg \psi } \vee f(e) = c \vee e = a )$ and $( \neg \psi \vee \bot^{ \neg \psi } \vee e \neq b )$.
After unit propagation in the second clause, we obtain $( e \neq b )$.
Now, in the first clause, the solver has a choice which literal to apply Decide to.
Say for the sake of argument we have that the solver chooses to assert $( f(e) = c )^d$.
Here we know that our counterexample must be such that $f( e ) = c$ and $e \neq b$.
We could suggest possible instantiations for $x$, but these may be unhelpful since $e$ is somewhat unconstrained.
However, if we had decided instead to assert $( e = a )^d$, we would immediately have discovered a theory conflict, thus determining that $\psi$ is valid and returning SAT. \\

The previous example illustrates the importance of exploring multiple partial truth assignments for literals involving instantiation constants.
More generally, when we reach a candidate-satisfiable state $M \parallel F$ in which the SMT solver believes it cannot proceed in a useful way, it may be beneficial for the SMT solver to backtrack and reverse the polarity of a decision in $M$ instead of exploring futile instantiations or answering UNKNOWN.

For this reason, we provide a method for flipping the polarity of the last eligible decision literal.
In particular, we are interested in reversing that last decision literal that has not already been flipped.
To enforce this scheme, we store a bit for each SAT literal saying whether or not it has been flipped.
When the quantifier instantiation module is stuck and requests a literal to be flipped, we scan $M$ in reverse order until it finds a literal $l$ for which this bit has not been set, backtracks to this decision, asserts $\neg l^d$, and sets the flipped bit for $l$.
For each literal $l'$ backtracked upon, it resets the flipped bit of $l'$.
If no such literal $l$ exists, the quantifier instantiation module has the option of either restarting the search at the top level or answering UNKNOWN.

\begin{comment}
\section{Summary}

A method for handling quantifiers in SMT has been presented.
This method focuses on finding a satisifying assignment for the negated body of the quantifiers $\psi$, and uses this information to guide instanstiations.
This is possible through the use of lemmas containing a counterexample literals $\neg \bot^\psi$, which in addition act as a way of recognizing satisfiable instances in a straightforward way.
An ideal implementation of this approach requires three additional features from the SAT solver, all which can be enforced in a reasonable way.
\end{comment}

\end{document}

