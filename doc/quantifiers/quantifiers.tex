\documentclass{llncs}
\usepackage{amsmath}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{comment}
%\usepackage{fullpage}
\usepackage{proof}
\usepackage{url}
\usepackage[pdftex]{graphicx}
\usepackage[usenames]{color}
\usepackage{capt-of}
\usepackage{program}

\newtheorem{thm}{Theorem}
\newtheorem{cor}{Corollary}

\newcommand{\interp}[1]{[ \negthinspace [ #1 ] \negthinspace ]}

\newcommand{\ednote}[1]{{\bf [#1]}\message{ednote!}}

\newcommand{\bassert}{|assert|_\mathrm{base}}
\newcommand{\iassert}{|assert|_\mathrm{ind}}
\newcommand{\bentail}{|entailed|_\mathrm{base}}
\newcommand{\ientail}{|entailed|_\mathrm{ind}}
\newcommand{\breset}{|reset|_\mathrm{base}}
\newcommand{\ireset}{|reset|_\mathrm{ind}}
\newcommand{\bcex}{|cex|_\mathrm{base}}
\newcommand{\icex}{|cex|_\mathrm{ind}}
\def\LOOP{\qtab\keyword{loop}\ }
\def\ENDLOOP{\untab}
\def\REPEAT{\qtab\keyword{repeat}\ }
\def\UNTIL{\untab\keyword{until}\ }
\def\IF{\qtab\keyword{if}\ }
\def\THEN{\ \keyword{then}\ }
\def\ELSE{\untab\qtab\keyword{else}\ }
\def\ELSEIF{\untab\qtab\keyword{else if}\ }
\def\FI{\untab}
\def\RETURN{\keyword{return}\ }
\def\ENDPROC{\untab}
\def\DOFOR{\qtab\keyword{for}\ }
\def\ENDFOR{\untab}
\def\COMMENT#1{\texttt{// #1}}
\def\keyword#1{\mbox{\normalshape\bf #1}}
\def\MATCH{\qtab\keyword{match}\ }
\def\WITH{\ \keyword{with}\ }
\def\ENDMATCH{\untab}
%\def\WHILE{\qtab\keyword{while}\ }
\def\ENDWHILE{\untab}

\newcommand{\To}{\Rightarrow}


\begin{document}
\pagenumbering{arabic}
\pagestyle{plain}

\title{A Counterexample-Based Approach for Quantifier Instantiation in SMT}

\author{Andrew Reynolds}
\institute{Computer Science, The University of Iowa, USA}

\date{}

\maketitle
\thispagestyle{empty}

\section{DPLL(T) Approach to Quantifiers}

When extending the DPPL(T) framework to handle formuls involving quantifiers, we rely on the following rules: \\

\noindent $\exists$-Inst: \\

$M \parallel F \Longrightarrow M \parallel F, \neg \exists \bar{x}. \varphi[ \bar{ x } ] \vee \varphi( \bar{ c } )$, if   
$\begin{cases}
  \exists \bar{x}. \varphi[ \bar{ x } ] \in M \\
  \bar{ c } \text{ are fresh constants} \\
\end{cases}$ \\

\noindent $\forall$-Inst: \\

$M \parallel F \Longrightarrow M \parallel F, \neg \forall \bar{x}. \varphi[ \bar{ x } ] \vee \varphi( \bar{ s } )$, if   
$\begin{cases}
  \forall \bar{x}. \varphi[ \bar{ x } ] \in M \\
  \bar{ s } \text{ are ground terms} \\
\end{cases}$ \\

We call the constants introduced in $\exists$-Inst as skolem constants.
Note that in the case of $\exists$-Inst, there is no benefit of instantiating more than once.

Note that the $\forall$-Inst rule always applies in DPLL(T) when a universal quantified formula is asserted, thus restricting the SMT solver from answering SAT.
Typically, repeated applications of $\forall$-Inst are tried until a conflict is discovered, or else the solver returns UNKNOWN.
The main challenges here are (1) determining relevant instantiations to use for the rule $\forall$-Inst, (2) determining when it is no longer worthwhile to apply $\forall$-Inst for a given quantifier, and furthermore (3) recognizing cases where \emph{all} necessary instantiations have been tried.

In current approaches, $E$-matching has been used as a method of addressing challenge (1).
In $E$-matching, subterms contained in a quantifier are matched against ground terms to find substitutions that are then used to instantiate a given quantifier.
While simple and effective, current approaches to $E$-matching are limited in their ability to determine the instantiations that are the most helpful at any given time.
As a result, often a brute force approach is used, in which many useless instantiations are produced in addition to those used to generate conflicts.

Approaches based on $E$-matching also suffer at times from what is known as a \emph{matching loop}, that is, a situation in which ground terms generated by instantiations may lead to matches of a repeating form.
Heuristics have been used to address the challenges of (2), including assigning an instantiation level to each ground term produced as a result of an instantiation.
By giving preference to matches using ground terms of a lower instantiation level, our instantiations effectively can be thought of as a bredth-first search.

Some SMT solvers employ what is known as \emph{complete instantiation} when dealing with problems containing quantifiers to address (3).
If the solver can recognize that the quantifier occurs in a decidable fragment of first order logic, then the solver may only need to try a finite number of instantiations before either finding a contradiction or determining the quantified formula is valid.
In the cases where the formula is found to be valid, then the solver may be able to answer SAT.

The following document reexamines challenges (1), (2) and (3).
We present a scheme for symbolically reasoning about counterexamples to quantified formulas within the DPLL(T) framework.
At a high level, for every (universally) quantified formula $\psi$ asserted in a given context, the solver will assume that a counterexample to $\psi$ exists, and reason about possible values for this counterexample.

In terms of challenge (1), the goal of this approach will be to leverage theory-specific information to aid in selecting instantiations.
Say we have a universally quantified formula $\forall x. \varphi[x]$ where $x$ is of a sort belonging to theory $T$.
The SMT solver will be interested in finding a satisifying assignment for $ \neg \varphi[e]$ where $e$ is a fresh constant of the same sort as $x$.
In other words, the value of $e$ will represent the possible values for which our quantified formula can be falsified.
The theory solver for $T$ will suggest instantiations for $x$ based on the internal information it has deduced involving $e$.
For the theory of $EUF$, this can be thought of as an extension to E-matching.

For challenge (3), it can be shown that if $\neg \varphi[e]$ is unsatisfiable in the current context for fresh constants $\bar{e}$, then our quantified formula is valid in the current context and need not be instantiated further.
This comes as an added benefit, and while not as powerful as techniques using complete instantiation, may lead to SAT instances when it is shown that a particular axiom does not apply in a particular context.

\subsection{Related Work}

\paragraph{Model-Based Quantifier Instantiation}
Model-Based Quantifier Instantiation (MBQI) has been proposed as a powerful method for addressing challenges (1) and (3).
For a quantified formula $\forall \bar{x}. \varphi(\bar{x})$
The goal of MBQI is to determine relevant instantiations using models to ground clauses in the current context.
More specifically, given a set of clauses $F$, we determine a candidate model $M^I$ for the ground clauses in $F$, as well as other restrictions $R$ on potential models.
For each quantified assertion $\forall x. \varphi[x] \in F$, we check the satisifiability of $R \wedge \neg \varphi^I[e]$, where $\varphi^I$ is generated by replacing all uninterpretted symbols in $\varphi$ with the interpretation in our model $M^I$.
In the case that this formula is satisfiable for some $\varphi^I[e]$, we use a model for this formula to instantiate $\forall x. \varphi[x]$, thereby ruling out the model $M^I$ on future iterations.
In the case that each of these formulas $R \wedge \neg \varphi^I[e]$ are unsatisifiable, then we know that our formula is SAT.

%However, a weakness of this approach is that it is not incremental.
%In other words, testing the satisfiability of formulas $R \wedge \neg \varphi^I[e]$ potentially comes at a large cost to the solver.

The technique proposed in this document takes a similar approach to quantifier instantiation, and is intended to simplify this scheme.
Instead of explicitly building models $M^I$ and reasoning about the interpretted form of clauses $\neg \varphi^I[e]$, we instead reason  about the negated body of non-ground clauses $\neg \varphi[e]$ for a fresh (distinguished) constant $e$, which we will refer to as an \emph{instantiation constant}.
This is done using the same instance of the SMT solver, that is, we may use an SMT solver to simultaneously reason about constructing satisfying assignments for ground clauses existing in a particular problem as well as clauses $\neg \varphi[e]$.
An immediate advantage here is that reasoning about the negated body of the quantifier is performed incrementally.
In this approach, when we have reached a DPLL(T) state $M \parallel F$, our current set of asserted literals $M$ not containing $e$ can be considered the implicit specification of a current model.

Based on possible values we find for $e$, our procedure will construct instantiations that are likely to be relevant in the current context, as well as decide when no helpful instantiations exist.
In the same manner as model-based quantifier instantiation, if we show that $\neg \varphi[e]$ is unsatisifiable in the current context for the fresh constant $e$, then we have shown that $\forall x. \varphi[x]$ is valid and need not be instantiated further in the current context.

\paragraph{E-matching}
E-matching is a powerful method for generating relevant instantiations based on matching \emph{triggers} with concrete ground terms. 
Say we have ground assertions $M$ and quantified assertion $\forall \bar{x}. \varphi$.
The idea of E-matching is to find a subterm (or set of subterms) $t$ of $\varphi$, called a \emph{trigger}, such that all variables $\bar{x}$ are contained in the free variables of $t$, and a vector of ground terms $\bar{s}$ such that $t[\bar{s}/\bar{x}]$ is equivalent to a ground subterm $g$ of $M$ modulo a set of ground equalities entailed by $M$.
In this case, we say that term $t$ \emph{E-matches} term $g$ and subsequently the set of ground terms $\bar{s}$ is used to instantiate the quantifier $\forall \bar{x}. \varphi$.

While modern methods can be used to compute E-matches in a highly efficient manner, a weakness of E-matching is its ability to recognize the relevance of instantiations in a precise way.
In particular, a basic implementation of E-matching does not consider the logical structure of the body of the quantifier $\varphi$.
As a result, many instantiations may potentially be needed to generate a conflict if one exists.

As a simple case, say we have the literals $f( a ) = g( a )$ and $\forall x. ( f(x) \neq g(x) \Rightarrow P( x ) )$ asserted in a particular context. 
An implementation of E-matching may choose $f( x )$ as a trigger and use $a$ as an instantiation for the quantifier.
However, this instantiation is useless since it falsifies the antecedant of the body of the quantifier.
To recognize such cases, it is useful to reason about the negated body of the quantifier for a fresh constant $e$, where in this case the SMT solver will assert the literals $f( e ) \neq g( e )$ and $\neg P( e )$.
This will suggest that we should be looking for a ground term $a$ such that $f( a ) \neq g( a )$, and ideally an $a$ in which $\neg P( a )$ holds as well.

The technique in the following can be thought of as an extension to E-matching, where now equalities and disequalities between triggers are considered.
This information provides a criteria for filtering irrelevant E-matches, as well as a way of quickly finding instantiations that are more likely to be relevant.

\section{DPLL(T) with Counterexample Literals}
\label{dpll-ce-lit}

In this section, we propose a scheme for reasoning about quantified formulas in SMT within the existing DPLL(T) framework.
This scheme will supplement DPLL(T) with an additional rule (Counterexample $\forall$-Inst) as well as enhancements for existing DPLL(T) rules related to quantifiers.
The core semantics of the DPLL(T) architechture will remain the same, that is, we still consider states of the form $M \parallel F$, where $M$ is a set of asserted literals and $F$ is a set of clauses.

\begin{comment}
Throughout the remainder of this document, we will assume that CNF-conversion has been applied to the body of all universally quantified formulas.
In other words, the only quantified formulas we consider are non-ground clauses of the form $\forall \bar{x}. ( l_1 \vee \ldots \vee l_n )[\bar{x}]$, where $l_1 \ldots l_n$ are theory literals.
\end{comment}

\subsection{Counterexample Literals}

Given an asserted quantifier $\forall \bar{x}. \varphi[\bar{x}]$ (call this formula $\psi$) and a DPLL(T) context $M \parallel F$, we are interested in finding a satisifying assignment for $ \neg \psi[\bar{e}]$ for fresh constants $\bar{e}$.
To do this, we will insert a valid lemma into $F$ that gives three possibilities for $\psi$: either $\psi$ is not asserted, $\psi$ does not have a counterexample, or $\psi$ has a counterexample, call it $\bar{e}$ such that $\neg \varphi[\bar{e}]$ holds.
We will first introduce the notion of a \emph{counterexample literal}.

For a quantified formula $\psi$ of the form $\forall \bar{ x }. \varphi$, we will associate a distinguished (boolean) literal called the \emph{counterexample literal of $\psi$}, and write $\bot^{\neg \psi}$ to denote this literal.
This literal states that ``a counterexample to $\psi$ does not exist", or in other words $\psi$ is valid in the current context.
The idea here is that although this entails the literal $\psi$ itself, we will in a sense trick the SAT-solver into believing they are in fact independent literals.

For a DPLL(T) state $M \parallel F$ and for each quantified formula $\psi = \forall \bar{ x }. \varphi[ \bar{ x } ] \in F$, we have three intended configurations for $\psi$ and its counterexample literal $\bot^{\neg \psi}$: \\

(1) $\psi$ is not asserted positively in $M$, 

(2) $\psi^{(d)}$ and $\neg (\bot^{\neg \psi})^d$ are asserted in $M$, 

(3) $\psi^{(d)}$ and $\bot^{\neg \psi}$ are asserted in $M$. \\

In case (1), our configuration does not claim $\psi$ to be true.
In case (2), our configuration has asserted (perhaps as a decision) that $\psi$ is true, but also has decided that it will find a counterexample.
In case (3), our configuration has asserted that $\psi$ is true, and moreover knows that $\psi$ does not have a counterexample.
To enforce this schema, we require that the DPLL(T) engine never assert $(\bot^{\neg \psi})^d$ as a decision, and that $\neg (\bot^{\neg \psi})^d$ should be asserted only after $\psi$ is asserted.
Both these requirements can be addressed within the core of the SAT solver with only a limited impact on performance, and neither of these are required to maintain soundness of the overall DPLL(T) system.

%In the following sections, lemmas of the form $( \neg \psi \vee \bot^{\neg \psi} \vee \neg \psi[\bar{e}/\bar{x}])$ will be added to our set of clauses $F$.
%Each of these clauses tell us that either $\psi$ does not hold, a counterexample does not exist for $\psi$, or the contraint $C(\bar{e})$ holds for the counterexample $\bar{e}$ of $\psi$,  where $\bar{e}$ are distinguished free constants of the same sorts as $\bar{x}$.
%In other words, if there exists a $\bar{t}$ such that $\psi[\bar{t}/\bar{x}]$ is unsatisifiable in $M$, then $C( \bar{t})$ is satisfiable in $M$.
%Note the contrapositive: if $C( \bar{e} )$ is unsatisfiable in $M$, then $\psi[\bar{t}/\bar{x}]$ is satisifiable in $M$ for all $\bar{t}$, or in other words, $\psi$ does not have a counterexample and $\psi$ is valid.

Consider the possible states (1), (2) and (3) of our configuration.
In case (1), if $\psi$ is asserted negatively, then the remainder of the clause $( \neg \psi \vee \bot^{\neg \psi} \vee \neg \psi[\bar{e}/\bar{x}])$ is ignored.
In the case of (3), the clause is satisfied by $\bot^{\neg \psi}$ and the solver will again ignore the information contained in $\neg \psi[\bar{e}/\bar{x}]$.

More interestingly, in the case of (2), the SAT-solver must find a satisfying assignment for $\neg \psi[\bar{e}/\bar{x}]$.
In particular, we will see that this will force the DPLL(T) engine to reason about models for our counterexample $\bar{e}$.
Furthermore, in the case where $\neg \psi[\bar{e}/\bar{x}]$ is unsatisifiable, this will signal for the SAT-solver to backjump and assert $\bot^{\neg \psi}$ positively as a non-decision literal, or in other words, a counterexample to $\psi$ cannot exist in the current context.
We will see that this will allow us to answer SAT instead of UNKNOWN in some cases.

\subsection{Instantiation Constants}

We will refer to distinguished free constants $\bar{e}$ as introduced in the previous section as \emph{instantiation constants}.
It is important to note that instantiation constants will have identical logical semantics as free constants of the same sort.
In other words, our scheme assumes no information about the value of an instantiation constant $e$, and uses this terminology as a way of referring to such constants.

We write $e \mapsto^I_i \forall \bar{x}. \varphi[ \bar{x} ]$ to denote that $e$ is the i$^{th}$ instantiation constant for the formula $\forall \bar{x}. \varphi[ \bar{x} ] $, and write $\bar{e} \mapsto^I \forall \bar{x}. \varphi[ \bar{x} ]$ to denote that $e_i \mapsto^I_i \forall \bar{x}. \varphi[ \bar{x} ]$ for all $e_i$ in $\bar{e}$.
For a literal $l$, we write $l \mapsto^I S$ to denote that $S = \{ \forall \bar{x}. \varphi[ \bar{x} ] \mid \exists e \in l. e \mapsto^I \forall \bar{x}. \varphi[ \bar{x} ] \}$, or in other words, all instantiation constants in $l$ refer to a quantified formula in $S$.
Furthermore write $C \mapsto^I S$ to denote that $S$ is the union of the sets $S_1 \ldots S_n$ for $l_i \in C$, $l_i \mapsto^I S_i$.
A concrete literal (clause) is one that contains no instantiation constants.
We consider a literal (clause) to be pure with respect to quantifiers if it contains instantiation constants from at most one quantified formula.
For convienience, we simply write $E \mapsto^I \forall \bar{x}. \varphi[ \bar{x} ]$ in the case that expression $E$ contains instantiation constants from exactly one.
An expression $E$ is \emph{concrete} if $E \mapsto^I \emptyset$.

\subsection{Counterexample Lemma for Quantified Formulas}

Consider the lemma $( \neg \psi \vee \bot^{\neg \psi} \vee \neg \psi[\bar{e}/\bar{x}])$, where $\bar{e} \mapsto^I \psi$.
We will refer to this formula as the \emph{counterexample lemma for $\psi$}.
Informally, this lemma is valid since $\bot^{\neg \psi}$ entails $\psi$, and thus $\neg \psi \vee \bot^{\neg \psi}$ is valid.
Note that $\neg \psi[\bar{e}/\bar{x}]$ may contain quantifiers.

{\bf Example 0}
Consider the formula $\psi = \forall x. ( l_1 \vee ( l_2 \vee x = a ) \Rightarrow \neg P( x ) )$.
Its counterexample lemma after conversion to CNF is $( \neg \psi \vee \bot^{\neg \psi} \vee \neg l_1 ) \wedge ( \neg \psi \vee \bot^{\neg \psi} \vee l_2 \vee e = a ) \wedge ( \neg \psi \vee \bot^{\neg \psi} \vee P( e ) ) $. \\

In Example 0, we have produced three clauses.
The first says that either $l_1$ is false or a counterexample does not exist to $\psi$.
The second says that either $l_2$ is true, a counterexample $\psi[e/x]$ exists such that $e = a$, or a counterexample does not exist to $\psi$. 
Similarly, the third says that either a counterexample $\psi[e/x]$ exists such that $P( e )$, or one does not exist.

\subsection{Counterexample $\forall$-Inst}

The counterexample lemma for a quantified formula $\psi$ can be used within the DPLL(T) framework.
The following rule adds the counterexample lemma $\forall \bar{x}. \varphi[ \bar{ x } ]$ to $F$, introducing $\bar{e}$ as the instantiation constants of $\psi$.
This rule represents the central idea behind our approach: \\

\noindent Counterexample $\forall$-Inst: \\

$M \parallel F \Longrightarrow M \parallel F, (\neg \forall \bar{x}. \varphi[ \bar{x} ] \vee \bot^{\neg \forall \bar{x}. \varphi[ \bar{x} ]} \vee \neg \varphi[ \bar{ e } ])$, if   
$\begin{cases}
  \forall \bar{x}. \varphi[ \bar{ x } ] \in M \\
  \bar{ e } \mapsto^I \forall \bar{x}. \varphi[ \bar{ x } ] \\
\end{cases}$ \\

Let us again consider Example 0.
By applying Counterexample $\forall$-Inst to $\psi$, we will produce three clauses $C_1, C_2, C_3$ after CNF-conversion:

$C_1 : ( \neg \psi \vee \bot^{\neg \psi} \vee \neg l_1 )$,

$C_2 : ( \neg \psi \vee \bot^{\neg \psi} \vee l_2 \vee e = a )$, and

$C_3 : ( \neg \psi \vee \bot^{\neg \psi} \vee P( e ) )$.

If we force the SMT solver to assert $\neg( \bot^{\neg \varphi} )^d$, it can be shown that the default behavior of DPLL(T) is sufficient and desirable for reasoning about clauses containing counterexample literals and literals with instantiation constants.

Let us first consider when we are in a state $M, \psi, \neg( \bot^{\neg \varphi} )^d, N \parallel F$, were $\psi$ has been asserted as a non-decision literal and its counterexample literal has been decided upon negatively.
In the case that $l_1$ is asserted positively (possibly as a decision) in $M = M_1, l^{(d)}_1, M_2$, we have that $C_1$ is falsified and we will backjump to the state $M, \psi, \bot^{\neg \varphi} \parallel F$.
This corresponds to saying that a counterexample cannot exist to $\psi$ in the context $M$ where $l_1$ is true.

In the case that $l_1$ is not asserted in $M$, we will apply Unit Propagation to $C_1$ and arrive in the state $M, \psi, \neg( \bot^{\neg \varphi} )^d, \neg l_1$ $\parallel F$.
This corresponds to saying that $l_1$ must be false if a counterexample to $\psi$ exists.
Note here that we are preferring to constrain ourselves to states in which a counterexample may occur.
This makes sense, both semantically since we have decided that a counterexample may exist (i.e. $\neg( \bot^{\neg \varphi} )^d$), and operationally since the DPLL(T) will reach a non-terminating state if it cannot prove that a counterexample exists.

%Otherwise, if $l_1^d$ had been asserted positively as a decision in $N$, $C_1$ is falsified and conflict analysis would proceed in the standard way to backjump to a state of the form $M, \psi, \neg( \bot^{\neg \varphi} )^d, N', \neg l_1 \parallel F$ or $M, \psi, \neg( \bot^{\neg \varphi} )  \parallel F$.
%In the former case, we have determined that some decision in $N$ has led us to require $l_1$ to be true thereby conflicting with our decision that a counterexample exists.
%In the latter case, we have determined that assuming a counterexample exists means that $l_1$ must be true and thus a counterexample cannot exist.

%Now consider the case where we are in a state $M, \psi^d, \neg( \bot^{\neg \varphi} )^d, N  \parallel F$ where now $\psi$ has been asserted as a decision literal.

%The cases here are identical with one notable exception.
%Take the case where we have encountered a conflict and backjumped to the state $M, \psi^d, \bot^{\neg \varphi} \parallel F$, that is, we know that $\psi$ does not have a counterexample.
%Note the lemma $(\neg (\bot^{\neg \psi}) \vee \psi)$, that is, either $\psi$ has a counterexample or $\psi$ holds.
%We can apply Backjump with $C' \vee l' = \neg (\bot^{\neg \psi}) \vee \psi$ to arrive at the state $M, \psi \parallel F$.
%Note, however that this lemma should not be added $F$, as it is exactly what we \emph{do not} want to tell the SAT-solver, as it encodes the trick of our approach.

The analysis for $C_2$ and $C_3$ are as expected, where now the DPLL(T) engine may give partial truth assignments to $l_2$, $e = a$ and $P( e )$, which later may be useful for determining instantiations.
Note in the context $M, \psi, \neg( \bot^{\neg \varphi} )^d, \neg l_2$, the literal $e = a$ will be unit propagated within $C_3$, thereby signalling that $\psi[a/x]$ is the \emph{only} instantiation we need to try in such a context.

We define the following invariants for DPLL(T): \\

{\bf Invariant 1}:
For all DPLL(T) states $M \parallel F$, the only instance of literal $\bot^{\neg \psi}$ in $F$ occur in clauses $C_1 \ldots C_n$ such that $C_1 \ldots C_n$ is logically equivalent to $( \neg \psi \vee \bot^{\neg \psi} \vee \neg \psi[\bar{e}/\bar{x}] )$ where $\bar{e} \mapsto^I \psi$.

{\bf Invariant 2}:
For all DPLL(T) states $M \parallel F$, all clauses $C \mapsto^I \psi$ in $F$ are tautological. \\

It can be shown that counterexample $\forall$-Inst maintains Invariants 1 and 2.
Also note that since counterexample literals $\bot^{ \neg \psi }$ have no meaning apart from representing boolean values, no lemma added to $F$ by $T$-Learn will violate Invariant 1.

\subsection{Enhancements for DPLL(T) Rules}

First, let us revisit the rule for $\forall$-Inst.
Note that we may restrict this rule to only be applicable to formulas $\forall \bar{x}. \varphi[ \bar{ x } ]$ in cases where a counterexample can exist to $\forall \bar{x}. \varphi[ \bar{ x } ]$.
Such cases can be easily recognized due to the following theorem:

\begin{thm}
For all DPLL(T) states of the form $M, \bot^{\neg \psi} \parallel F$, if no literal $l \mapsto^I \psi$ is asserted as a decision in $M$, then $M \models_T \psi[\bar{t}/\bar{x}]$ for all $\bar{t}$, or in other words, $\psi$ is valid in the context $M$.
\end{thm}
\begin{proof}
Assume we have a DPLL(T) state $M, \bot^{\neg \psi} \parallel F$, where $\bot^{\neg \psi}$ is asserted as a non-decision literal.

Consider the case where $\bot^{\neg \psi}$ was asserted by unit-propagation.
Since $\psi$ is in $M$, by Invariant 1, it must be the case that $M \models \psi[\bar{e}/\bar{x}]$.
Since no literal $l \mapsto^I \psi$ is asserted as a decision in $M$, we can construct an explanation $N \subseteq M$ such that $N \models \psi[\bar{e}/\bar{x}]$ and $N$ does not contain $\bar{e}$.
Since $\bar{e}$ do not occur in $N$, we have $N \models \psi[\bar{t}/\bar{x}]$ for all vectors of terms $\bar{t}$, and therefore $M \models \psi[\bar{t}/\bar{x}]$ as well.

Consider the case where $\bot^{\neg \psi}$ was asserted due to a backjump.
The reasoning here is similar, where now a conflict was discovered for a clause of the form $( \neg \psi \vee \bot^{\neg \psi} \vee l_1[\bar{e}] \vee \ldots \vee l_n[\bar{e}])$, where $\neg l_1[\bar{e}] \wedge \ldots \wedge \neg l_n[\bar{e}] \Rightarrow \psi$.
If no literal $l \mapsto^I \psi$ is asserted as a decision literal in $M$, we construct an explanation as before to show $\psi$ is valid in $M$.
$\Box$
\end{proof}

Accordingly, we wish to use a search strategy in which no literal $l^d \mapsto^I \psi$ can be asserted as a decision when $(\bot^{\neg \psi})^d$ is not asserted.
This scheme may be enforced within the core of the SAT solver when chosing a decision literal.
When the SAT solver decides on a literal $l \mapsto^I \psi$, it checks if a value has been given to $(\bot^{\neg \psi})^d$.
If it has not, then it chooses another literal to decide upon.
This restriction gives only a small impact on performance [determine this].

We also require that no terms used to instantiate a quantifier contain instantiation constants.
Our updated rule for $\forall$-Inst becomes the following: \\

\noindent $\forall$-Inst (Counterexample Restricted): \\

$M \parallel F \Longrightarrow M \parallel F, (\neg \forall \bar{x}. \varphi[ \bar{ x } ] \vee \varphi( \bar{ s } ))$, if   
$\begin{cases}
  \forall \bar{x}. \varphi[ \bar{ x } ] \in M, \bar{ s } \mapsto^I \emptyset, \\
  \bot^{\neg \forall \bar{x}. \varphi[ \bar{ x } ]} \text{ is not asserted positively }\\
  \text{ \ \ \ as a non-decision literal in $M$ } \\    
\end{cases}$ \\

The restricted form for this rule is helpful when trying to establish a satisifiable instance of a formula involving quantifiers.
The following example shows a simple instance where the solver can return SAT by determining that a counterexample cannot exist to a universally quantified formula in a particular context. \\

{\bf Example 1}
Say we wish to determine the satisifiability of the set of formulas $S = \{ a = b, (\psi :) \forall x. ((f(x) = a \wedge f(x) \neq b) \Rightarrow l) \}$.
After two applications of Unit Propagation, we arrive in the DPLL(T) state $( a = b ), \psi \parallel S$.
After using Counterexample $\forall$-Inst, our state becomes $( a = b ), \psi \parallel (S':) S \cup \{ (\neg \psi \vee \bot^{\neg \psi} \vee f( e ) = a), (\neg \psi \vee \bot^{\neg \psi} \vee f( e ) \neq b)), (\neg \psi \vee \bot^{\neg \psi} \vee \neg l) \}$.
Say the solver decides that $\psi$ has a counterexample, and our state becomes $( a = b ), \psi, \neg (\bot^{\neg \psi})^d \parallel S'$. 
After unit propagation our state becomes $\ldots, f( e ) = a, f( e ) \neq b, \neg l \parallel S'$, and we encounter the EUF theory conflict $a = b, f( e ) = a, f( e ) \neq b \models \bot$.
After conflict analysis, we will backtrack to the state $( a = b ), \psi, (\bot^{\neg \psi}) \parallel S'$, and now notice that all clauses in $S'$ are satisfied and $\forall$-Inst does not apply to $\psi$.
The solver answers SAT. \\

Here, we have determined $S$ is satisfiable by noting that any model where $a = b$ is true also satisfies $\psi$ for all possible values for $x$.
One can also view this scenario as determining that the axiom $\psi$ is not applicable in the context where $a = b$.

We say a DPLL(T) state $M \parallel F$ is \emph{candidate-satisifiable} if all clauses in $F$ are satisified and $M$ is $T$-consistent.
We say a quantified formula $\psi \in M$ is \emph{counterexample-active} in $M \parallel F$ if Counterexample $\forall$-Inst has been applied to $\psi$ and $\neg (\bot^{\neg \psi})^d \in M$.

\begin{thm}
\label{thm:cerep}
Given a candidate-satisifiable DPLL(T) state $M \parallel F$ and a quantified formula $\forall \bar{x}. \varphi[ \bar{x} ] \in M$ that is counterexample-active in $M$, we have that $M \models \neg \varphi[\bar{e}]$.
\end{thm}

\subsection{Learned Lemmas Containing Instantiation Constants}

It is also important to note that learned lemmas can involve instantiation constants.
In Example 1, after the theory conlifct, we could have added the lemma $( f( e ) \neq a \vee f( e ) = b \vee a \neq b )$ to $S'$.
For a larger example, this lemma may potentially be useful in pruning the search space of subsequently when searching for a counterexample to $\psi$.

\begin{comment}
It is also important to note that learned lemmas can involve instantiation constants.
In this example, after the theory conlifct, we could have added the lemma $(\varphi_1 : ) ( f( e ) \neq a \vee f( e ) = b \vee a \neq b )$ to $S'$.
In this case, we may apply Decide to come to the state $( a = b ), \psi, (\bot^{\neg \psi}), (f( e ) \neq a)^d \parallel S' \cup \varphi$, where again all clauses are satisfied, and the solver answers SAT in the same manner.

However, note that the lemma $\varphi_1$ is only useful in contexts in which $\psi$ is asserted.
In other words, the solver should not be searching for values of counterexamples to quantified formulas $\psi$ when $\psi$ is not asserted.
We will see in Section~\ref{sec:implementation} a recommended implementation for which this concern is addressed.
[do this: do these lemmas pollute the DPLL(T) space?  When should we forget them?  Should we give them to minisat?]
[do this: examine elaborating lemmas involving instantiation constants as being lemmas involving universal statements, justify as well]
\end{comment}

\section{Quantifier Instantiation Using Instantiation Constants}

In this section, we describe theory-specific methods for determining relevant instantiations using information we have deduced about instantiation constants $\bar{e}$ within a theory solver.

We begin with the following definitions:
An instantiation constant $e$ is \emph{solved in $M$} if $e$ does not exist in $M$, or there exists a concrete ground term $s$ such that $M \models_T (e = s)$.
An instantiation constant $e$ is \emph{unsolved in $M$} otherwise.
Similarly, a term $t$ is \emph{unsolved in $M$} if it contains instantiation constants that are unsolved in $M$; a term $t$ is \emph{solved in $M$} otherwise.
Note that concrete ground terms $t$ are solved for all $M$.

Given a quantified formula $\psi$ is \emph{instantiation-ready in $M$} if and only if $M$ is $T$-consistent and all $e_i \mapsto^I \psi$ in $M$ are solved in $M$.
For an instantiation-ready quantified formula $\psi$, define $\varepsilon_M( e_1 ) \ldots \varepsilon_M( e_n )$ as a vector of concrete ground terms such that if $e_i$ is in $M$, then $M \models_T (e_i = \varepsilon_M( e_1 ))$.

The usefulness of determining whether a quantified formula $(\psi:) \ \forall \bar{x}. \varphi[ \bar{x} ]$ is instantiation-ready is immediate:  if $\psi$ is counterexample active in candidate satsifiable $M \parallel F$, we know that $\neg \varphi[ \bar{e} ]$ is entailed in our current model.
If we also know that $\bar{e} = \bar{s}$, then we know that the instantiation $\varphi[ \bar{s} ]$ must be \emph{unsatisfiable} in the current state.

\begin{thm}
\label{thm:instready}
Given a candidate-satisifiable DPLL(T) state $M \parallel F$, for all quantified formula $\psi$ of the form $\forall \bar{x}. \varphi[ \bar{x} ]$, if $\psi$ is counterexample-active in $M \parallel F$ and instantiation-ready in $M$, then $\psi[\varepsilon_M( \bar{e} )/\bar{x}]$ is $T$-unsatisfiable in $M$, where $\bar{e} \mapsto^I \psi$.
\end{thm}
\begin{proof}
Consider the quantified formula $\psi$ of the form $\forall \bar{x}. \varphi[ \bar{x} ]$.
Assume $\psi$ is counterexample-active in $M \parallel F$ and instantiation-ready in $M$.
By Theorem~\ref{thm:cerep}, we have that $M \models \neg \varphi[\bar{e}]$.
Since $\varepsilon_{M}( e ) = e$ for all $e \in M$, we know that $M \models \neg \varphi[\varepsilon_M( \bar{e} )]$ and thus $\psi[\varepsilon_M( \bar{e} )/\bar{x}]$ is $T$-unsatisfiable in $M$. $\Box$
\end{proof}

\begin{cor}
\label{cor:instready}
Given a candidate-satisifiable DPLL(T) state $M \parallel F$, for all quantified formula $\psi \in M$,
if $\psi$ is counterexample-active in $M \parallel F$ and instantiation-ready in $M$, then the instantiation clause $( \neg \psi$ $\vee$ $\psi[\varepsilon_{M}( \bar{e} )/\bar{x}])$ has not been added to $F$.
\end{cor}
\begin{proof}
The proof is immediate, noting that by Theorem~\ref{thm:instready}, $( \neg \psi \vee \psi[\varepsilon_{M}( \bar{e} )/\bar{x}])$ is $T$-unsatisifiable in $M$, and therefore cannot be satisfied in $M \parallel F$. $\Box$
\end{proof}

In other words, Theorem~\ref{thm:instready} states that if we can find a state $M$ in which we have solved for values of all instantiation constants for $\psi$, we can construct an instantiation for $\psi$ that is guarenteed to lead to a conflict in $M$.
Corollary~\ref{cor:instready} states that if we can find such an instantiation, then it has not yet been applied.
This fact guarentees that no redundant instantiations are used in certain instantiation schemes.

\subsection{Quantifier Instantiation for EUF}

A method for quantifier instantiation in EUF is presented here, which uses information that is asserted as a result of searching for satisifying assignments to the negated bodies of quantifiers.
Say we are given a quantified formula $\psi$ of the form $\forall x. \varphi[x]$ where $x$ is of an uninterpretted sort.
We will search for a satisfying assignment to $\neg \varphi[e]$, and use information asserted about $e$ a basis for determining what values should be used for $x$ to instantiate $\psi$.
The EUF theory solver will process equalities and disequalities between both terms containing instantiation constants and those without.
Since instantiation constants have identical logical semantics to non-instantiation constants, equalities between terms containing instantiation constants may be treated identically, that is, the EUF theory solver is used as is.

Say the equality $t[e] = s$ is entailed in the current context.
The goal of this approach will be to find a ground term $g$ such that $M \models t[g] = s$ has maximum likelihood to hold.
If $M \models t[g] = s$ for some $g$, then $g$ is a strong candidate for instantiating $\psi$ in the current context.
On the other hand, if $M \models t[g] \neq s$, then $g$ is useless as an instantiation in the current context with respect to $t[e] = s$.
Otherwise if $t[g] = s$ is satisifiable in $M$, then $g$ is potentially useful as an instantiation in the current context.

In terms of $E$-matching, this approach treats terms containing instantiation constants as triggers for instantiation.
In addition however, it also takes into consideration entailed equalities and disequalities between such triggers.
This enables a powerful search method for determining relevant instantiations, as well as a criteria for judging the relevance of instantiations that are produced.
For the former, we can imagine an approach in which we first search only the equivalence class of $t[e]$ for another term of the form $t[s]$, and if none can be found, search the remainder of the concrete ground terms existing in the current context.
For the latter, we may filter instantiations $g$ if, for example, $e = g$ is unsatisifiable in the current context.

Our approach for quantifier instantiation for EUF will be divided into multiple iterations, where on each subsequent iteration, less restrictions are imposed upon the instantiations that are generated.
On the final iteration, our approach will be roughly equivalent to E-matching, where all triggers $t[\bar{e}]$ are matched against all concrete ground terms $g$.
We begin our discussion by introducing necesary terminology.
We first describe how to determine if a literal is induced by a set of equalities between instantiation constants and concrete ground terms.

Say we have an equality of the form $f( \bar{t} )[\bar{e}] = g$ in $M$, and we wish to find a set of equalities $\bar{e} = \bar{s}$ that are sufficient to show that $f( \bar{t} )[\bar{e}] = g$ must be true.
In other words, we want to find $\bar{s}$ such that $M \backslash (f( \bar{t} )[\bar{e}] = g), \bar{e} = \bar{s} \models (f( \bar{t} )[\bar{e}] = g)$.
Note the subtle difference between this and E-matching.
In E-matching, we are searching for a substitution $\bar{s}$ such that $f( \bar{t} )[\bar{s}]$ is syntactically equivalent to $g$ modulo our set of ground equalities.
In this approach, we need only consider the equalities necessary to induce $f( \bar{t} )[\bar{e}]$ to be equal to $g$, possibly using equalities between triggers already existing in $M$.

Consider the following simple example.
Say we have the quantifier $\psi$ of the form $\forall x. (g(x) = a \Rightarrow f( x, g( x ) ) \neq f( b, a ))$.
After applying Counterexample $\forall$-Inst, we will have the literals $g(e) = a$ and $f( e, g( e ) ) = f( b, a )$ asserted in the current context for $e \mapsto^I \psi$.
Note that $e = b$ suffices to show that $f( e, g( e ) ) = f( b, a )$ in this example, suggesting that we may wish to use $b$ to instantiate $\psi$.
In a basic implementation of E-matching, $f( x, g( x ) )$ and $f( b, a )$ do not E-match.

For an equality $f( \bar{t} )[\bar{e}] = g$ asserted in $M$, we wish to find a set of equalities of the form $\bar{e_1} = \bar{s_1}$ where $\bar{e_1}$ is a subset of $\bar{e}$ that are sufficient for showing this equality.
The following method $e\_ind$ computes a set of such equality sets:

\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |e\_ind|(t,g,M,\psi) \BODY
  \IF t \not\mapsto^I \psi, g \not\mapsto^I \emptyset \text{ or } M \models t \neq g \THEN
    \RETURN \emptyset;
  \ELSEIF t \text{ is inst. constant } \THEN
    \IF M \models t = g \THEN
      \RETURN \{ \emptyset \};
    \ELSE
      \RETURN \{ \{ t = rep(g) \} \};
    \FI
  \ELSEIF t, g \text{ are $f( \bar{t_a} )$, $f( \bar{g_a} )$ } \THEN
    S := \{ \emptyset \};
    \DOFOR \text{each } t_i \text{ in } \bar{t_a} 
      \IF M \models t_i \neq g_i \THEN
        \RETURN \emptyset;
      \ELSEIF M \not\models t_i = g_i
        S' := e\_ind\_mod( t_i, g_i, M, \psi );
        S := merge( S, S' );
      \FI
    \ENDFOR
    \RETURN S;
  \ELSE
    \RETURN \emptyset;
  \FI
\ENDPROC
\end{program}
\end{minipage}
\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |e\_ind\_mod|(t,g,M,\psi) \BODY
  S := \emptyset;
  \DOFOR \text{each } g_i = g
    S := S \cup e\_ind( t, g_i, M,\psi );
  \ENDFOR
  \RETURN S;
\ENDPROC
\end{program}
\begin{program}
\PROC |merge|(S_1,S_2) \BODY
  S'' := \emptyset;
  \DOFOR E_1 \in S_1, E_2 \in S_2
    \IF E_1 \text{ and } E_2 \text{ are compatible }
      S'' := S'' \cup \{ E_1 \cup E_2 \}
    \FI
  \ENDFOR
  \RETURN S'';
\ENDPROC
\end{program}
\end{minipage}

The method $e\_ind(t,g,M,\psi)$ is intended to be applied where $t$ contains instantiation constants from $\psi$ and $g$ is a concrete ground term.
If these preconditions are not met or if $t$ is disequal from $g$, the method returns the empty set.
In the case that $t$ is an instantiation constant, the method returns the set containg a single set of equalities, containing $t = rep( g )$ if necessary, where $rep( g )$ denotes the (concrete ground) representative term of the equivalence class containing $g$.
If $t$ is of the form $f(\bar{t})$ and g is of the form $f(\bar{g})$, then the method scans each pair of arguments $t_i, g_i$ and computes, modulo equality, a set of equality sets $S'$ such that $t_i = g_i$ is induced in $M$.
For each set $S'$ produced in this way, it merges this set with $S$ using the method $merge$.
This method pairwise combines $S_1$ and $S_2$ to form the set $S''$.
For each pair $E_1 \in S_1$, $E_2 \in S_2$, if $E_1$ and $E_2$ are compatible, that is, there does not exist an equality $e = t_1$ in $E_1$ and $e = t_2$ in $E_2$ and $t_1$ is not syntactically equivalent to $t_2$, then the union of $E_1$ and $E_2$ is added to $S''$.

Otherwise, if $t$ is of the form $f(\bar{t})$ and $g$ is not of the form $f( \bar{g})$ for some $\bar{g}$, the method $e\_ind(t,g,M)$ returns the empty set, or in other words $t$ and $g$ do not match.

%More generally, we will say that a literal $L$ is $E$-induced in $M$ if $M \backslash L, E \models L$, where $E$ is a set of equalities of the form $e_1 = s_1 \ldots e_n = s_n$, that is, equalities whose left hand sides are instantiation constants.

\begin{comment}
We will also be interested in classifying which pairs of terms may potentially be $E$-induced.
For a quantified formula $\psi$, a term $f( t_1, \ldots, t_n ) \mapsto^I \psi$ is \emph{equality-compatible with term $s$ in $M$} if and only if $s$ is of the form $f( s_1, \ldots s_n )$ and $M \models_T t_1 = s_1 \wedge \ldots \wedge t_n = s_n$.
A term $f( t_1, \ldots, t_n ) \mapsto^I \psi$ is \emph{equality-independent from term $s$ in $M$} if (a) $s$ is of the form $g( s_1, \ldots s_m )$, or (b) $s$ is of the form $f( s_1, \ldots s_n )$ in $M$, and $M \models_T t_i \neq s_i$ for some $i$. 
A pair of terms $t, s$ where $t \mapsto^I \psi$ is \emph{equality-ambiguous} if $t$ is neither equality-compatible nor equality-independent from $s$.
\end{comment}

\subsubsection{E-Matching Using Equalities and Disequalities Between Triggers}

We now describe a method for determining instantiations for a quantified formula $\psi$ of the form $\forall \bar{x}. \varphi[\bar{x}]$, where $\bar{x}$ are of uninterpretted sorts.
We are interested in finding an instantiation $\bar{s}$ for $\psi$ in a candidate-satisfiable DPLL(T) state $M \parallel F$, where $\psi$ is counterexample-active in $M$ for $\bar{e} \mapsto^I \psi$.

Our method for quantifier instantiation in EUF will consist of four iterations, where in each iteration we relax the constraints we place on constructing instantiations.
In particular, each iteration can be shown to produce a superset of instantiations produced on the previous step.
The method terminates when an iteration successfully produces an instantiation, or when the last iteration has completed.

\begin{comment}
On the first iteration, we return the instantiation $\varepsilon_M( \bar{e} )$ if and only if $\psi$ is instantiation-ready.
On the second iteration, we determine if there exists a set of terms $\bar{s}$ such that we can determine that at least one of $L_1[\bar{e}] \ldots L_n[\bar{e}]$ is $(\bar{s} = \bar{e})$-induced in $M$.
On the third iteration, we will search for equality-ambiguous pairs of terms $t[\bar{e}]$ and $s$ in the same equivalence classes.  
Specifically, we will construct an instantiation $\bar{s}$ such that an equality between a subterm position of $t[\bar{e}]$ and $s$ is induced by $\bar{s} = \bar{e}$ on this step.
On the fourth iteration, we find a set of terms $\bar{s}$ that induce at least one equality between a pair of terms $t[\bar{e}]$ and $g$.
Note that this step is roughly equivalent to basic E-matching.
\end{comment}

\paragraph{First Iteration: Instantiation-Ready}

On the first iteration of quantifier instantiation for $\psi$, we check to see if each $e_i$ in $\bar{e}$ that is present in $M$ exists in the same equivalence class as a concrete ground term $\varepsilon_M(e_i)$.
For each $e_i$ not present in $M$, we pick an arbitrary concrete ground term if one exists, or a fresh constant otherwise.
If we can construct a vector of terms of this form, we return only this instantiation.
By Theorem~\ref{thm:instready}, this instantiation is \emph{guarenteed} to lead to a conflict, and the DPLL(T) engine will backtrack.

\paragraph{Second Iteration: A Literal is E-Induced in M}

If $\psi$ is not instantiation ready, we determine if any literal $L \mapsto^I \psi$ can be induced by a set of equalities $\bar{e} = \bar{s}$.
This can be summarized in the following method, which generates a set of equality sets $S$ for $L$ such that $L$ is $E$-induced in $M$ for each $E$ in $S$:

\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |e\_ind\_lit|(L,M,\psi) \BODY
  S := \emptyset;
  L \text{ is } t[\bar{e}] \sim s;
  \IF s \mapsto^I \emptyset \THEN
    \DOFOR \text{each $g$, where } g \sim s
      S := S \cup e\_ind( t[\bar{e}], g, M, \psi );
    \ENDFOR
  \ELSEIF s \mapsto^I \psi
    \DOFOR \text{each } g, h \text{ where } g \sim h
      S := S \cup merge( e\_ind( t[\bar{e}], g, M, \psi ), e\_ind( s, h, M, \psi ) );
    \ENDFOR 
  \FI
  \RETURN S;
\ENDPROC
\end{program}
\end{minipage}

When $L[\bar{e}]$ is an equality or disequality of the form $t[\bar{e}] \sim s$ and $s$ is a concrete ground term, we return the union of $e\_ind( t[\bar{e}], g, M, \psi )$ for each term $g$ such that $g \sim s$.
Otherwise if $s$ also contains instantiation constants from $\psi$, we scan each pair of terms $g$ and $h$ such that $g \sim h$ and $t[\bar{e}] = g$ and $s = h$ are induced by sets of equality sets.
If this is the case, we merge these sets and add them to our overall set $S$.

Note that the method $e\_ind\_lit$ will generate equality sets where $e_i = t$ need not be in $E$ for each $e_i$ in $\bar{e}$.
To construct a full instantiation $\bar{e} = \bar{s}$ from $E$, we must add equalities for each instantiation constant $e_i$ not existing in $E$.
The following method describes the overall procedure used in the second iteration for generating instantiations:

\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |generate\_inst_2|(M, \psi) \BODY
S_{L1} \ldots S_{Ln};
\DOFOR \text{each } L_i \in M \text{, where } L_i \mapsto^I \psi
  S_{Li} := e\_ind\_lit( L_i, M, \psi );
\ENDFOR
S := combine( S_{L1}, \ldots, S_{Ln} );
\RETURN \{ E^\varepsilon \mid E \in S, E \text{ is complete for $\psi$ } \};
\ENDPROC
\end{program}
\end{minipage}
\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |combine|(S_1, \ldots, S_n) \BODY
S := \emptyset;
\DOFOR i=1 \TO n
  S := S \cup S_i \cup merge( S, S_i );
\ENDFOR
\RETURN S;
\ENDPROC
\end{program}
\end{minipage}

After computing a set of equality sets $S_L$ for each literal $L \mapsto^I \psi$ in $M$, we combine these sets so that equality sets containing all instantiation constants $\bar{e} \mapsto^I \psi$ are constructed.
In terms of E-matching, this serves a similar purpose as \emph{multi-triggers}.
We call an equality set $E$ is \emph{complete for $\psi$} if it contains an equality $e_i = t_i$ for each unsolved $e_i \mapsto^I \psi$, \emph{incomplete for $\psi$} otherwise.
For a complete equality set $E$, we define the equality set $E^\varepsilon$ as the equality set containing $E$ as well as equalities $ e = \varepsilon_M( e )$ for each solved $e \mapsto^I \psi$ not existing in $E$.

Our method uses the $combine$ method to generate all possible combinations of equality sets that induce a subset of the literals $L_1 \ldots L_n$.
The method then returns an instantiation for each equality set $E$ produced as a result of our combination step that is complete for $\psi$.
On this iteration, if all instantiation literals for $\psi$ are induced by some equality set $E$, then the corresponding instantiation for $E$ is guarenteed to lead to a conflict.

\paragraph{Third Iteration: A Literal is Partially Matched}

If no instantiations are produced on the second iteration, we try to find an instantiation that is relevant in finding a match for a literal $L \mapsto^I \psi$.
In this iteration, we do not require that $L$ is $E$-induced in $M$, but we do require that a partial match has been found for the topmost symbol of a term in $L$.
For example, say we have that $M \models f( a, e ) = f( b, c )$ and that neither $a = b$ or $a \neq b$ is entailed in $M$.  
Here, we may wish to try the instantiation $c$ for the variable of $e$, since doing so partially matches our pattern to a concrete ground term that is relevant with respect to the equality $f( a, e ) = f( b, c )$.

Overall, this iteration uses a similar approach as the previous one, where instead of generating equality sets $E$ that induce $L_i$, we generate equality sets for which part of $L_i$ is matched to a concrete ground term.
First, let us define the method $part\_e\_ind$, which returns a set of equality sets which give a partial match for $t = g$:

\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |part\_e\_ind|(t,g,M, \psi) \BODY
\IF e\_ind( t, g, M, \psi ) \neq \emptyset \THEN
  \RETURN e\_ind( t, g, M, \psi );
\ELSEIF t, g \text{ are $f( \bar{t_a} )$, $f( \bar{g_a} )$ } \THEN
  S := \emptyset;
  \DOFOR \text{each } t_i \text{ in } \bar{t_a} 
    \IF M \models t_i \neq g_i \THEN
      \RETURN \emptyset;
    \ELSEIF M \not\models t_i = g_i
      S' := part\_e\_ind\_mod( t_i, g_i, M, \psi );
      S := S \cup S';
    \FI
  \ENDFOR
  \RETURN S;
\ELSE
  \RETURN \emptyset;
\FI
\ENDPROC
\end{program}
\end{minipage}
\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |part\_e\_ind\_mod|(t,g,M,\psi) \BODY
  S := \emptyset;
  \DOFOR \text{each } g_i = g
    S' := part\_e\_ind( t_i, g_i, M,\psi );
    S := S \cup S';
  \ENDFOR
  \RETURN S;
\ENDPROC
\end{program}
\end{minipage}

This method will first check to see if there is a set of equality sets that induce $t = g$, and if successful, return this set.
Otherwise, it will construct a set of equalities for which a subterm position (or set of subterm positions) of $t$ and $g$ are induced to be equal.
The definition of $part\_e\_ind\_mod$ is analogous to $e\_ind\_mod$, where now partial matches are calculated modulo equality.
The key difference between the method for generating partial matches and $e\_ind( t, g, M )$ is that in the application case we take the union of $S$ and the partial match for each argument, or in other words, we do not require the matches found for the arguments match.

Overall, the third iteration can be described by the following method, which produces a set of instantiations for $\psi$.
The definition of $part\_e\_ind\_lit$ is similar $e\_ind\_lit$ as described earlier, where instead partial matches are allowed.

\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |generate\_inst_3|(M, \psi) \BODY
S_{L1} \ldots S_{Ln};
\DOFOR \text{each } L_i \in M \text{, where } L_i \mapsto^I \psi
  S_{Li} := part\_e\_ind\_lit( L_i, M, \psi );
\ENDFOR
S := combine( S_{L1}, \ldots, S_{Ln} );
\RETURN \{ E^\varepsilon \mid E \in S, E \text{ is complete for $\psi$ } \};
\ENDPROC
\end{program}
\end{minipage}

\paragraph{Fourth Iteration: Match all Triggers with all Ground Terms}

If we are unable to produce an instantiation in the third iteration, we know that no pair of terms is relevant for matching with respect to equalities and disequalities.
In this case, we must search all concrete ground terms for matches against our triggers.
This can be summarized in the following method:

\begin{minipage}[t]{.4\linewidth}
\begin{program}
\PROC |generate\_inst_4|(M, \psi) \BODY
S_{L1} \ldots S_{Ln};
\DOFOR \text{each } L_i \in M \text{, where } L_i \mapsto^I \psi
  L_i \text{ is } t \sim s;
  \DOFOR \text{each } g \mapsto^I \emptyset
    S_{Li} := S_{Li} \cup part\_e\_ind( t, g, M, \psi ) \cup part\_e\_ind( s, g, M, \psi );
  \ENDFOR
\ENDFOR
S := combine( S_{L1}, \ldots, S_{Ln} );
\RETURN \{ E^\varepsilon \mid E \in S, E \text{ is complete for $\psi$ } \};
\ENDPROC
\end{program}
\end{minipage}

Note that we only consider the top-most terms of instantiation literals as triggers in this step.
Since we only require partial matches here, this iteration will in most cases produce an instantiation. \\

{\bf Example 1}
Consider the set of clauses $S = \{ (\psi_1 :) \ \forall x. G( S( x ), x), (\psi_2 :) \forall xyz. (G(x,y) \wedge G(y,z)) \Rightarrow G(x,z), \neg G( S(S(a)), a) \}$.
Note that $S$ represents a successor function and $G$ represents ``is greater than".  
In other words, this set of clauses says that $a + 2 > a$ is not true for some constant $a$.

After unit propagations and Counterexample $\forall$-Inst, we have the set of assertions $\psi_1$, $\psi_2$, $G( S(S(a)), a)$ = $G( S(e_1), e_1)$ = $G( e_2, e_4 )$ = $\bot$, $G( e_2, e_3 )$ = $G( e_3, e_4 )$ = $\top$, where $\top$ and $\bot$ are the distinguished free boolean constant representing true and false, $e_1 \mapsto^I \psi_1$ and $e_2, e_3, e_4 \mapsto^I \psi_2$.

Say we wish to perform a round of instantiation for $\psi_1, \psi_2$.
In the first iteration, neither $\psi_1$ or $\psi_2$ are instantiation ready.
In the second iteration, we find that $G( e_2, e_4 ) = \top$ is induced by $e_2, e_4 = S(S(a)), a$, but this does not produce an instantiation since $e_3$ is unspecified and a complete equality set cannot be produced for $\psi_2$.
In the third iteration, we find that the term $G( S(e_1), e_1)$ partially matches with the term $G( S(S(a)), a)$ for both $S(a)/e_1$ and $a/e_1$.
This iteration succeeds and adds the instantiation clauses $( \neg \psi_1 \vee \psi_1[S(a)/x])$ and $( \neg \psi_1 \vee \psi_1[a/x])$ to $F$.

After finding a satisfying assignment for these clauses by Unit propagation, we reach a state where $G( S(S(a)), a)$ = $G( S(e_1), e_1)$ = $G( e_2, e_4 )$ = $\bot$, $G( e_2, e_3 )$ = $G( e_3, e_4 )$ = $G(S(S(a)), S(a))$ = $G( S(a), a)$ = $\top$.
Again, neither $\psi_1$ and $\psi_2$ is instantiation ready.
In the second iteration, we find that $G( e_2, e_3 ) = \top$ is induced by $e_2,e_3$ = $S(S(a)), S(a)$, and $G( e_3, e_4 )$ is induced by $e_3, e_4$ = $S(a), a$.
During our combination step, we produce the equality set $e_2, e_3, e_4$ = $S(S(a)), S(a), a$ and use these values to instantiate $\psi_2$.
In fact, all instantiation literals from $\psi_2$ are induced by this instantiation, and as a result a conflict is discovered at the top level and the solver answers UNSAT.

\section{Enumerating Values for Decision Literals}

We have an approach for quantifier instantiation in SMT that is capable of producing relevant instantiations as well as recognizing certain cases in which a quantifier is guarenteed to have no relevant instantiations. 
In this section, we will consider how to proceed in states where a quantified formula $\forall \bar{x}. \varphi[ \bar{x} ]$ is neither valid nor easily shown to be unsatisfiable. \\

{\bf Example 3} 
Say we wish to determine the satisfiability of the set of clauses $S = \{ a = b, (\psi :) \forall x. ((f(x) = c \vee x = a) \Rightarrow x = b) \}$.
After applying Unit Propagation twice, applying Decide on $\neg (\bot^{ \neg \psi })^d$, and applying Counterexample $\forall$-Inst, we obtain the clauses $( \neg \psi \vee \bot^{ \neg \psi } \vee f(e) = c \vee e = a )$ and $( \neg \psi \vee \bot^{ \neg \psi } \vee e \neq b )$.
After unit propagation in the second clause, we obtain $( e \neq b )$.
Now, in the first clause, the solver has a choice which literal to apply Decide to.
Say for the sake of argument we have that the solver chooses to assert $( f(e) = c )^d$.
Here we know that our counterexample must be such that $f( e ) = c$ and $e \neq b$.
We could suggest possible instantiations for $x$, but these may be unhelpful since $e$ is somewhat unconstrained.
However, if we had decided instead to assert $( e = a )^d$, we would immediately have discovered a theory conflict, thus determining that $\psi$ is valid and returning SAT. \\

The previous example illustrates the importance of exploring multiple partial truth assignments for literals involving instantiation constants.
More generally, when we reach a candidate-satisfiable state $M \parallel F$ in which the SMT solver believes it cannot proceed in a useful way, it may be beneficial for the SMT solver to backtrack and reverse the polarity of a decision in $M$ instead of answering UNKNOWN or exploring futile instantiations.

For this reason, we provide a method for flipping the polarity of the last eligible decision literal.
In particular, we are interested in reversing that last decision literal that has not already been flipped.
To enforce this scheme, we store a bit for each SAT literal saying whether or not it has been flipped.
When the quantifier instantiation module is stuck and requests a literal to be flipped, we scan $M$ in reverse order until it finds a literal $l$ for which this bit has not been set, backtracks to this decision, asserts $\neg l^d$, and sets the flipped bit for $l$.
For each literal $l'$ backtracked upon, it resets the flipped bit of $l'$ to false.
If no such literal $l$ exists, the quantifier instantiation module has the option of either restarting or answering UNKNOWN.

\end{document}

